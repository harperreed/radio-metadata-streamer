This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: **/*.log, **/uv.lock, **/package-lock.json, **/.env, **/Cargo.lock, **/node_modules, **/target, **/dist, **/build, **/output.txt, **/yarn.lock, **/uv.lock, **/package-lock.json, **/.env, **/Cargo.lock, **/node_modules, **/target, **/dist, **/build, **/output.txt, **/yarn.lock, **/.private-journal
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cmd/
  icyproxy/
    main.go
configs/
  example.yaml
docs/
  plans/
    2025-10-15-multi-station-icy-proxy.md
  spec.md
  started.md
internal/
  application/
    config/
      config_test.go
      config.go
    manager/
      manager_test.go
      manager.go
  domain/
    station/
      station_test.go
      station.go
    interfaces.go
  infrastructure/
    http/
      handlers_test.go
      handlers.go
    icy/
      encoder_test.go
      encoder.go
    metadata/
      http_test.go
      http.go
    ring/
      buffer_test.go
      buffer.go
    source/
      http_test.go
      http.go
.dockerignore
.gitignore
config.yaml
docker-compose.yaml
Dockerfile
go.mod
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="configs/example.yaml">
 1: listen:
 2:   host: 0.0.0.0
 3:   port: 8000
 4: stations:
 5:   - id: "fip"
 6:     icy:
 7:       name: "FIP (proxy)"
 8:       metaint: 16384
 9:       bitrate_hint_kbps: 128
10:     source:
11:       url: "https://icecast.radiofrance.fr/fip-hifi.aac"
12:       request_headers:
13:         Icy-MetaData: "0"
14:       connect_timeout_ms: 5000
15:       read_timeout_ms: 15000
16:     metadata:
17:       url: "https://fip-metadata.fly.dev/"
18:       poll_ms: 3000
19:       build:
20:         format: "StreamTitle='{artist} - {title}';"
21:         strip_single_quotes: true
22:         normalize_whitespace: true
23:     buffering:
24:       ring_bytes: 262144
25:   - id: "nts"
26:     icy:
27:       name: "NTS Radio 1 (proxy)"
28:       metaint: 16384
29:       bitrate_hint_kbps: 128
30:     source:
31:       url: "https://stream-mixtape-geo.ntslive.net/stream"
32:       request_headers:
33:         Icy-MetaData: "0"
34:       connect_timeout_ms: 5000
35:       read_timeout_ms: 15000
36:     metadata:
37:       url: "https://www.nts.live/api/v2/live"
38:       poll_ms: 5000
39:       build:
40:         format: "StreamTitle='{artist} - {title}';"
41:         strip_single_quotes: true
42:         normalize_whitespace: true
43:     buffering:
44:       ring_bytes: 262144
45: logging:
46:   level: info
47:   json: false
</file>

<file path="docs/plans/2025-10-15-multi-station-icy-proxy.md">
   1: # Multi-Station ICY Metadata Proxy Implementation Plan
   2: 
   3: > **For Claude:** Use `${SUPERPOWERS_SKILLS_ROOT}/skills/collaboration/executing-plans/SKILL.md` to implement this plan task-by-task.
   4: 
   5: **Goal:** Build a multi-station ICY metadata proxy that streams MP3 audio with injected metadata for FIP and NTS radio.
   6: 
   7: **Architecture:** Domain-driven hexagonal architecture with three layers: domain (Station, interfaces), application (StationManager, config), and infrastructure (HTTP implementations, ICY encoding, ring buffer). Each station runs 3 goroutines: source reader, metadata poller, and per-client handlers. Uses channels for fan-out and atomic pointers for metadata.
   8: 
   9: **Tech Stack:** Go 1.23+, stdlib only, YAML config (gopkg.in/yaml.v3), Docker multi-stage build
  10: 
  11: ---
  12: 
  13: ## Task 1: Project Initialization
  14: 
  15: **Files:**
  16: - Create: `go.mod`
  17: - Create: `.gitignore`
  18: 
  19: **Step 1: Initialize Go module**
  20: 
  21: Run:
  22: ```bash
  23: go mod init github.com/harper/radio-metadata-proxy
  24: ```
  25: 
  26: Expected: Creates `go.mod` with module declaration
  27: 
  28: **Step 2: Add YAML dependency**
  29: 
  30: Run:
  31: ```bash
  32: go get gopkg.in/yaml.v3
  33: ```
  34: 
  35: Expected: Adds yaml.v3 to go.mod
  36: 
  37: **Step 3: Create .gitignore**
  38: 
  39: Create `.gitignore`:
  40: ```
  41: # Binaries
  42: icyproxy
  43: *.exe
  44: *.exe~
  45: *.dll
  46: *.so
  47: *.dylib
  48: 
  49: # Test artifacts
  50: *.test
  51: *.out
  52: 
  53: # Go workspace file
  54: go.work
  55: 
  56: # IDE
  57: .vscode/
  58: .idea/
  59: *.swp
  60: *.swo
  61: ```
  62: 
  63: **Step 4: Commit**
  64: 
  65: Run:
  66: ```bash
  67: git add go.mod go.sum .gitignore
  68: git commit -m "feat: initialize Go project with yaml dependency"
  69: ```
  70: 
  71: ---
  72: 
  73: ## Task 2: ICY Block Encoder
  74: 
  75: **Files:**
  76: - Create: `internal/infrastructure/icy/encoder.go`
  77: - Create: `internal/infrastructure/icy/encoder_test.go`
  78: 
  79: **Step 1: Write failing test for empty metadata**
  80: 
  81: Create `internal/infrastructure/icy/encoder_test.go`:
  82: ```go
  83: // ABOUTME: Tests for ICY metadata block encoding
  84: // ABOUTME: Verifies padding, length byte calculation, and truncation
  85: package icy
  86: 
  87: import (
  88: 	"testing"
  89: )
  90: 
  91: func TestBuildBlock_Empty(t *testing.T) {
  92: 	result := BuildBlock("")
  93: 	if len(result) != 1 || result[0] != 0x00 {
  94: 		t.Errorf("empty string should produce single zero byte, got %v", result)
  95: 	}
  96: }
  97: ```
  98: 
  99: **Step 2: Run test to verify failure**
 100: 
 101: Run:
 102: ```bash
 103: go test ./internal/infrastructure/icy/...
 104: ```
 105: 
 106: Expected: FAIL with "no Go files in internal/infrastructure/icy"
 107: 
 108: **Step 3: Write minimal implementation**
 109: 
 110: Create `internal/infrastructure/icy/encoder.go`:
 111: ```go
 112: // ABOUTME: ICY metadata block encoding for Shoutcast/Icecast protocol
 113: // ABOUTME: Handles 16-byte padding and length byte calculation per ICY spec
 114: package icy
 115: 
 116: func BuildBlock(text string) []byte {
 117: 	if text == "" {
 118: 		return []byte{0x00}
 119: 	}
 120: 	return []byte{0x00}
 121: }
 122: ```
 123: 
 124: **Step 4: Run test to verify pass**
 125: 
 126: Run:
 127: ```bash
 128: go test ./internal/infrastructure/icy/...
 129: ```
 130: 
 131: Expected: PASS
 132: 
 133: **Step 5: Write failing test for non-empty metadata**
 134: 
 135: Add to `internal/infrastructure/icy/encoder_test.go`:
 136: ```go
 137: func TestBuildBlock_ShortString(t *testing.T) {
 138: 	result := BuildBlock("StreamTitle='Test';")
 139: 
 140: 	// Should be: length byte + 20 chars + 12 padding = 33 bytes
 141: 	if len(result) != 33 {
 142: 		t.Errorf("expected 33 bytes, got %d", len(result))
 143: 	}
 144: 
 145: 	// Length byte should be 2 (2 * 16 = 32 bytes of data+padding)
 146: 	if result[0] != 2 {
 147: 		t.Errorf("expected length byte 2, got %d", result[0])
 148: 	}
 149: 
 150: 	// Verify content
 151: 	content := string(result[1:21])
 152: 	if content != "StreamTitle='Test';" {
 153: 		t.Errorf("expected 'StreamTitle='Test';', got %q", content)
 154: 	}
 155: 
 156: 	// Verify padding is zeros
 157: 	for i := 21; i < 33; i++ {
 158: 		if result[i] != 0x00 {
 159: 			t.Errorf("byte %d should be 0x00, got 0x%02x", i, result[i])
 160: 		}
 161: 	}
 162: }
 163: ```
 164: 
 165: **Step 6: Run test to verify failure**
 166: 
 167: Run:
 168: ```bash
 169: go test ./internal/infrastructure/icy/... -v
 170: ```
 171: 
 172: Expected: FAIL on length check
 173: 
 174: **Step 7: Implement full encoding logic**
 175: 
 176: Update `internal/infrastructure/icy/encoder.go`:
 177: ```go
 178: // ABOUTME: ICY metadata block encoding for Shoutcast/Icecast protocol
 179: // ABOUTME: Handles 16-byte padding and length byte calculation per ICY spec
 180: package icy
 181: 
 182: import "bytes"
 183: 
 184: // BuildBlock encodes text as ICY metadata block with 16-byte padding.
 185: // Returns length byte (count of 16-byte chunks) followed by padded payload.
 186: // Max size: 255 * 16 = 4080 bytes.
 187: func BuildBlock(text string) []byte {
 188: 	if text == "" {
 189: 		return []byte{0x00}
 190: 	}
 191: 
 192: 	payload := []byte(text)
 193: 
 194: 	// Truncate if exceeds max (255 blocks * 16 bytes)
 195: 	if len(payload) > 255*16 {
 196: 		payload = payload[:255*16]
 197: 	}
 198: 
 199: 	// Calculate blocks (round up)
 200: 	blocks := (len(payload) + 15) / 16
 201: 	if blocks > 255 {
 202: 		blocks = 255
 203: 	}
 204: 
 205: 	// Calculate padding
 206: 	pad := blocks*16 - len(payload)
 207: 
 208: 	// Build result: length byte + payload + padding
 209: 	var buf bytes.Buffer
 210: 	buf.WriteByte(byte(blocks))
 211: 	buf.Write(payload)
 212: 	if pad > 0 {
 213: 		buf.Write(bytes.Repeat([]byte{0x00}, pad))
 214: 	}
 215: 
 216: 	return buf.Bytes()
 217: }
 218: ```
 219: 
 220: **Step 8: Run tests to verify pass**
 221: 
 222: Run:
 223: ```bash
 224: go test ./internal/infrastructure/icy/... -v
 225: ```
 226: 
 227: Expected: PASS (2 tests)
 228: 
 229: **Step 9: Write test for truncation**
 230: 
 231: Add to `internal/infrastructure/icy/encoder_test.go`:
 232: ```go
 233: func TestBuildBlock_Truncation(t *testing.T) {
 234: 	// Create string larger than max (255 * 16 = 4080 bytes)
 235: 	longStr := string(make([]byte, 5000))
 236: 	result := BuildBlock(longStr)
 237: 
 238: 	// Length byte should be 255
 239: 	if result[0] != 255 {
 240: 		t.Errorf("expected length byte 255, got %d", result[0])
 241: 	}
 242: 
 243: 	// Total length should be 1 + 255*16 = 4081 bytes
 244: 	expected := 1 + 255*16
 245: 	if len(result) != expected {
 246: 		t.Errorf("expected %d bytes, got %d", expected, len(result))
 247: 	}
 248: }
 249: ```
 250: 
 251: **Step 10: Run tests to verify pass**
 252: 
 253: Run:
 254: ```bash
 255: go test ./internal/infrastructure/icy/... -v
 256: ```
 257: 
 258: Expected: PASS (3 tests)
 259: 
 260: **Step 11: Commit**
 261: 
 262: Run:
 263: ```bash
 264: git add internal/infrastructure/icy/
 265: git commit -m "feat: implement ICY metadata block encoding with tests"
 266: ```
 267: 
 268: ---
 269: 
 270: ## Task 3: Ring Buffer
 271: 
 272: **Files:**
 273: - Create: `internal/infrastructure/ring/buffer.go`
 274: - Create: `internal/infrastructure/ring/buffer_test.go`
 275: 
 276: **Step 1: Write failing test for ring buffer creation**
 277: 
 278: Create `internal/infrastructure/ring/buffer_test.go`:
 279: ```go
 280: // ABOUTME: Tests for circular ring buffer implementation
 281: // ABOUTME: Verifies write, wrap-around, overflow, and snapshot operations
 282: package ring
 283: 
 284: import (
 285: 	"testing"
 286: )
 287: 
 288: func TestNew(t *testing.T) {
 289: 	buf := New(1024)
 290: 	if buf == nil {
 291: 		t.Fatal("New should return non-nil buffer")
 292: 	}
 293: 
 294: 	snap := buf.Snapshot()
 295: 	if len(snap) != 0 {
 296: 		t.Errorf("new buffer should be empty, got %d bytes", len(snap))
 297: 	}
 298: }
 299: ```
 300: 
 301: **Step 2: Run test to verify failure**
 302: 
 303: Run:
 304: ```bash
 305: go test ./internal/infrastructure/ring/...
 306: ```
 307: 
 308: Expected: FAIL with "no Go files"
 309: 
 310: **Step 3: Write minimal implementation**
 311: 
 312: Create `internal/infrastructure/ring/buffer.go`:
 313: ```go
 314: // ABOUTME: Circular ring buffer for audio stream smoothing
 315: // ABOUTME: Drops oldest data on overflow to maintain fixed size
 316: package ring
 317: 
 318: import "sync"
 319: 
 320: type Buffer struct {
 321: 	buf []byte
 322: 	w   int  // write position
 323: 	n   int  // bytes stored
 324: 	mu  sync.Mutex
 325: }
 326: 
 327: func New(size int) *Buffer {
 328: 	return &Buffer{buf: make([]byte, size)}
 329: }
 330: 
 331: func (b *Buffer) Snapshot() []byte {
 332: 	b.mu.Lock()
 333: 	defer b.mu.Unlock()
 334: 	return make([]byte, b.n)
 335: }
 336: ```
 337: 
 338: **Step 4: Run test to verify pass**
 339: 
 340: Run:
 341: ```bash
 342: go test ./internal/infrastructure/ring/... -v
 343: ```
 344: 
 345: Expected: PASS
 346: 
 347: **Step 5: Write failing test for simple write**
 348: 
 349: Add to `internal/infrastructure/ring/buffer_test.go`:
 350: ```go
 351: func TestWrite_Simple(t *testing.T) {
 352: 	buf := New(1024)
 353: 	data := []byte("hello")
 354: 
 355: 	buf.Write(data)
 356: 
 357: 	snap := buf.Snapshot()
 358: 	if string(snap) != "hello" {
 359: 		t.Errorf("expected 'hello', got %q", snap)
 360: 	}
 361: }
 362: ```
 363: 
 364: **Step 6: Run test to verify failure**
 365: 
 366: Run:
 367: ```bash
 368: go test ./internal/infrastructure/ring/... -v
 369: ```
 370: 
 371: Expected: FAIL on snapshot comparison
 372: 
 373: **Step 7: Implement Write method**
 374: 
 375: Add to `internal/infrastructure/ring/buffer.go`:
 376: ```go
 377: func (b *Buffer) Write(p []byte) {
 378: 	b.mu.Lock()
 379: 	defer b.mu.Unlock()
 380: 
 381: 	for len(p) > 0 {
 382: 		space := len(b.buf) - b.n
 383: 		if space == 0 {
 384: 			// Drop oldest 25%
 385: 			drop := len(b.buf) / 4
 386: 			b.w = (b.w + drop) % len(b.buf)
 387: 			b.n -= drop
 388: 			if b.n < 0 {
 389: 				b.n = 0
 390: 			}
 391: 			space = len(b.buf) - b.n
 392: 		}
 393: 
 394: 		chunk := len(p)
 395: 		if chunk > space {
 396: 			chunk = space
 397: 		}
 398: 
 399: 		end := (b.w + b.n) % len(b.buf)
 400: 		right := len(b.buf) - end
 401: 		if right > chunk {
 402: 			right = chunk
 403: 		}
 404: 
 405: 		copy(b.buf[end:end+right], p[:right])
 406: 		if right < chunk {
 407: 			copy(b.buf[0:chunk-right], p[right:chunk])
 408: 		}
 409: 
 410: 		b.n += chunk
 411: 		p = p[chunk:]
 412: 	}
 413: }
 414: ```
 415: 
 416: **Step 8: Update Snapshot to return actual data**
 417: 
 418: Update `Snapshot` in `internal/infrastructure/ring/buffer.go`:
 419: ```go
 420: func (b *Buffer) Snapshot() []byte {
 421: 	b.mu.Lock()
 422: 	defer b.mu.Unlock()
 423: 
 424: 	out := make([]byte, b.n)
 425: 	if b.n == 0 {
 426: 		return out
 427: 	}
 428: 
 429: 	head := b.w
 430: 	tail := (b.w + b.n) % len(b.buf)
 431: 
 432: 	if head < tail {
 433: 		copy(out, b.buf[head:tail])
 434: 	} else {
 435: 		copy(out, b.buf[head:])
 436: 		copy(out[len(b.buf)-head:], b.buf[:tail])
 437: 	}
 438: 
 439: 	return out
 440: }
 441: ```
 442: 
 443: **Step 9: Run tests to verify pass**
 444: 
 445: Run:
 446: ```bash
 447: go test ./internal/infrastructure/ring/... -v
 448: ```
 449: 
 450: Expected: PASS (2 tests)
 451: 
 452: **Step 10: Write test for overflow behavior**
 453: 
 454: Add to `internal/infrastructure/ring/buffer_test.go`:
 455: ```go
 456: func TestWrite_Overflow(t *testing.T) {
 457: 	buf := New(100)
 458: 
 459: 	// Write 150 bytes - should trigger overflow
 460: 	data := make([]byte, 150)
 461: 	for i := range data {
 462: 		data[i] = byte(i)
 463: 	}
 464: 
 465: 	buf.Write(data)
 466: 
 467: 	snap := buf.Snapshot()
 468: 
 469: 	// Should have dropped oldest 25 bytes, kept newest 100
 470: 	if len(snap) != 100 {
 471: 		t.Errorf("expected 100 bytes, got %d", len(snap))
 472: 	}
 473: 
 474: 	// Should contain bytes 50-149 (dropped 0-49)
 475: 	for i, v := range snap {
 476: 		expected := byte(50 + i)
 477: 		if v != expected {
 478: 			t.Errorf("byte %d: expected %d, got %d", i, expected, v)
 479: 			break
 480: 		}
 481: 	}
 482: }
 483: ```
 484: 
 485: **Step 11: Run tests to verify pass**
 486: 
 487: Run:
 488: ```bash
 489: go test ./internal/infrastructure/ring/... -v
 490: ```
 491: 
 492: Expected: PASS (3 tests)
 493: 
 494: **Step 12: Commit**
 495: 
 496: Run:
 497: ```bash
 498: git add internal/infrastructure/ring/
 499: git commit -m "feat: implement ring buffer with overflow handling"
 500: ```
 501: 
 502: ---
 503: 
 504: ## Task 4: Domain Interfaces
 505: 
 506: **Files:**
 507: - Create: `internal/domain/interfaces.go`
 508: 
 509: **Step 1: Create domain interfaces**
 510: 
 511: Create `internal/domain/interfaces.go`:
 512: ```go
 513: // ABOUTME: Domain interfaces for dependency inversion
 514: // ABOUTME: Allows station to depend on abstractions, not concrete implementations
 515: package domain
 516: 
 517: import (
 518: 	"context"
 519: 	"io"
 520: )
 521: 
 522: // StreamSource provides MP3 audio stream bytes
 523: type StreamSource interface {
 524: 	Connect(ctx context.Context) (io.ReadCloser, error)
 525: }
 526: 
 527: // MetadataProvider fetches current track metadata
 528: type MetadataProvider interface {
 529: 	Fetch(ctx context.Context) (string, error)
 530: }
 531: ```
 532: 
 533: **Step 2: Commit**
 534: 
 535: Run:
 536: ```bash
 537: git add internal/domain/interfaces.go
 538: git commit -m "feat: add domain interfaces for stream source and metadata provider"
 539: ```
 540: 
 541: ---
 542: 
 543: ## Task 5: Station Domain Model (Part 1 - Structure)
 544: 
 545: **Files:**
 546: - Create: `internal/domain/station/station.go`
 547: - Create: `internal/domain/station/station_test.go`
 548: 
 549: **Step 1: Write failing test for station creation**
 550: 
 551: Create `internal/domain/station/station_test.go`:
 552: ```go
 553: // ABOUTME: Tests for station domain model
 554: // ABOUTME: Verifies lifecycle, client management, and metadata updates
 555: package station
 556: 
 557: import (
 558: 	"testing"
 559: )
 560: 
 561: func TestNew(t *testing.T) {
 562: 	cfg := Config{
 563: 		ID:      "test",
 564: 		MetaInt: 16384,
 565: 	}
 566: 
 567: 	s := New(cfg, nil, nil, nil)
 568: 
 569: 	if s.ID() != "test" {
 570: 		t.Errorf("expected ID 'test', got %q", s.ID())
 571: 	}
 572: }
 573: ```
 574: 
 575: **Step 2: Run test to verify failure**
 576: 
 577: Run:
 578: ```bash
 579: go test ./internal/domain/station/...
 580: ```
 581: 
 582: Expected: FAIL with "no Go files"
 583: 
 584: **Step 3: Write minimal station structure**
 585: 
 586: Create `internal/domain/station/station.go`:
 587: ```go
 588: // ABOUTME: Station domain model coordinating streaming, metadata, and clients
 589: // ABOUTME: Manages lifecycle of goroutines for source reading and metadata polling
 590: package station
 591: 
 592: import (
 593: 	"context"
 594: 	"sync"
 595: 	"sync/atomic"
 596: 	"time"
 597: 
 598: 	"github.com/harper/radio-metadata-proxy/internal/domain"
 599: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/ring"
 600: )
 601: 
 602: type Config struct {
 603: 	ID             string
 604: 	ICYName        string
 605: 	MetaInt        int
 606: 	BitrateHint    int
 607: 	PollInterval   time.Duration
 608: 	RingBufferSize int
 609: 	ChunkBusCap    int
 610: }
 611: 
 612: type Station struct {
 613: 	id          string
 614: 	icyName     string
 615: 	metaInt     int
 616: 	bitrateHint int
 617: 
 618: 	source   domain.StreamSource
 619: 	metadata domain.MetadataProvider
 620: 	buffer   *ring.Buffer
 621: 
 622: 	pollInterval time.Duration
 623: 
 624: 	currentMeta   atomic.Pointer[string]
 625: 	lastMetaAt    atomic.Pointer[time.Time]
 626: 	sourceHealthy atomic.Bool
 627: 
 628: 	clients   map[*Client]struct{}
 629: 	clientsMu sync.Mutex
 630: 
 631: 	chunkBus chan []byte
 632: 
 633: 	ctx    context.Context
 634: 	cancel context.CancelFunc
 635: }
 636: 
 637: type Client struct {
 638: 	ID string
 639: }
 640: 
 641: func New(cfg Config, source domain.StreamSource, metadata domain.MetadataProvider, buffer *ring.Buffer) *Station {
 642: 	return &Station{
 643: 		id:           cfg.ID,
 644: 		icyName:      cfg.ICYName,
 645: 		metaInt:      cfg.MetaInt,
 646: 		bitrateHint:  cfg.BitrateHint,
 647: 		source:       source,
 648: 		metadata:     metadata,
 649: 		buffer:       buffer,
 650: 		pollInterval: cfg.PollInterval,
 651: 		clients:      make(map[*Client]struct{}),
 652: 		chunkBus:     make(chan []byte, cfg.ChunkBusCap),
 653: 	}
 654: }
 655: 
 656: func (s *Station) ID() string {
 657: 	return s.id
 658: }
 659: ```
 660: 
 661: **Step 4: Run test to verify pass**
 662: 
 663: Run:
 664: ```bash
 665: go test ./internal/domain/station/... -v
 666: ```
 667: 
 668: Expected: PASS
 669: 
 670: **Step 5: Commit**
 671: 
 672: Run:
 673: ```bash
 674: git add internal/domain/station/
 675: git commit -m "feat: add station domain model structure"
 676: ```
 677: 
 678: ---
 679: 
 680: ## Task 6: Station Domain Model (Part 2 - Metadata)
 681: 
 682: **Files:**
 683: - Modify: `internal/domain/station/station.go`
 684: - Modify: `internal/domain/station/station_test.go`
 685: 
 686: **Step 1: Write failing test for metadata access**
 687: 
 688: Add to `internal/domain/station/station_test.go`:
 689: ```go
 690: func TestStation_CurrentMetadata(t *testing.T) {
 691: 	cfg := Config{
 692: 		ID:      "test",
 693: 		MetaInt: 16384,
 694: 	}
 695: 
 696: 	s := New(cfg, nil, nil, nil)
 697: 
 698: 	// Initially empty
 699: 	if meta := s.CurrentMetadata(); meta != "" {
 700: 		t.Errorf("expected empty metadata, got %q", meta)
 701: 	}
 702: 
 703: 	// Set metadata
 704: 	s.UpdateMetadata("StreamTitle='Test';")
 705: 
 706: 	if meta := s.CurrentMetadata(); meta != "StreamTitle='Test';" {
 707: 		t.Errorf("expected 'StreamTitle='Test';', got %q", meta)
 708: 	}
 709: }
 710: ```
 711: 
 712: **Step 2: Run test to verify failure**
 713: 
 714: Run:
 715: ```bash
 716: go test ./internal/domain/station/... -v
 717: ```
 718: 
 719: Expected: FAIL with "undefined: Station.CurrentMetadata"
 720: 
 721: **Step 3: Implement metadata methods**
 722: 
 723: Add to `internal/domain/station/station.go`:
 724: ```go
 725: func (s *Station) CurrentMetadata() string {
 726: 	p := s.currentMeta.Load()
 727: 	if p == nil {
 728: 		return ""
 729: 	}
 730: 	return *p
 731: }
 732: 
 733: func (s *Station) UpdateMetadata(meta string) {
 734: 	s.currentMeta.Store(&meta)
 735: 	now := time.Now()
 736: 	s.lastMetaAt.Store(&now)
 737: }
 738: 
 739: func (s *Station) LastMetadataUpdate() *time.Time {
 740: 	return s.lastMetaAt.Load()
 741: }
 742: ```
 743: 
 744: **Step 4: Run tests to verify pass**
 745: 
 746: Run:
 747: ```bash
 748: go test ./internal/domain/station/... -v
 749: ```
 750: 
 751: Expected: PASS (2 tests)
 752: 
 753: **Step 5: Commit**
 754: 
 755: Run:
 756: ```bash
 757: git add internal/domain/station/
 758: git commit -m "feat: add metadata management to station"
 759: ```
 760: 
 761: ---
 762: 
 763: ## Task 7: Station Domain Model (Part 3 - Client Management)
 764: 
 765: **Files:**
 766: - Modify: `internal/domain/station/station.go`
 767: - Modify: `internal/domain/station/station_test.go`
 768: 
 769: **Step 1: Write failing test for client management**
 770: 
 771: Add to `internal/domain/station/station_test.go`:
 772: ```go
 773: func TestStation_ClientManagement(t *testing.T) {
 774: 	cfg := Config{
 775: 		ID:      "test",
 776: 		MetaInt: 16384,
 777: 	}
 778: 
 779: 	s := New(cfg, nil, nil, nil)
 780: 
 781: 	if count := s.ClientCount(); count != 0 {
 782: 		t.Errorf("expected 0 clients, got %d", count)
 783: 	}
 784: 
 785: 	client := &Client{ID: "c1"}
 786: 	s.AddClient(client)
 787: 
 788: 	if count := s.ClientCount(); count != 1 {
 789: 		t.Errorf("expected 1 client, got %d", count)
 790: 	}
 791: 
 792: 	s.RemoveClient(client)
 793: 
 794: 	if count := s.ClientCount(); count != 0 {
 795: 		t.Errorf("expected 0 clients after removal, got %d", count)
 796: 	}
 797: }
 798: ```
 799: 
 800: **Step 2: Run test to verify failure**
 801: 
 802: Run:
 803: ```bash
 804: go test ./internal/domain/station/... -v
 805: ```
 806: 
 807: Expected: FAIL with "undefined: Station.ClientCount"
 808: 
 809: **Step 3: Implement client management methods**
 810: 
 811: Add to `internal/domain/station/station.go`:
 812: ```go
 813: func (s *Station) AddClient(c *Client) {
 814: 	s.clientsMu.Lock()
 815: 	s.clients[c] = struct{}{}
 816: 	s.clientsMu.Unlock()
 817: }
 818: 
 819: func (s *Station) RemoveClient(c *Client) {
 820: 	s.clientsMu.Lock()
 821: 	delete(s.clients, c)
 822: 	s.clientsMu.Unlock()
 823: }
 824: 
 825: func (s *Station) ClientCount() int {
 826: 	s.clientsMu.Lock()
 827: 	defer s.clientsMu.Unlock()
 828: 	return len(s.clients)
 829: }
 830: ```
 831: 
 832: **Step 4: Run tests to verify pass**
 833: 
 834: Run:
 835: ```bash
 836: go test ./internal/domain/station/... -v
 837: ```
 838: 
 839: Expected: PASS (3 tests)
 840: 
 841: **Step 5: Commit**
 842: 
 843: Run:
 844: ```bash
 845: git add internal/domain/station/
 846: git commit -m "feat: add client management to station"
 847: ```
 848: 
 849: ---
 850: 
 851: ## Task 8: Station Domain Model (Part 4 - Health & Properties)
 852: 
 853: **Files:**
 854: - Modify: `internal/domain/station/station.go`
 855: - Modify: `internal/domain/station/station_test.go`
 856: 
 857: **Step 1: Write failing test for health and properties**
 858: 
 859: Add to `internal/domain/station/station_test.go`:
 860: ```go
 861: func TestStation_Properties(t *testing.T) {
 862: 	cfg := Config{
 863: 		ID:          "fip",
 864: 		ICYName:     "FIP Radio",
 865: 		MetaInt:     16384,
 866: 		BitrateHint: 128,
 867: 	}
 868: 
 869: 	s := New(cfg, nil, nil, nil)
 870: 
 871: 	if s.ICYName() != "FIP Radio" {
 872: 		t.Errorf("expected ICYName 'FIP Radio', got %q", s.ICYName())
 873: 	}
 874: 
 875: 	if s.MetaInt() != 16384 {
 876: 		t.Errorf("expected MetaInt 16384, got %d", s.MetaInt())
 877: 	}
 878: 
 879: 	if s.BitrateHint() != 128 {
 880: 		t.Errorf("expected BitrateHint 128, got %d", s.BitrateHint())
 881: 	}
 882: 
 883: 	if s.SourceHealthy() {
 884: 		t.Error("expected SourceHealthy false initially")
 885: 	}
 886: 
 887: 	s.SetSourceHealthy(true)
 888: 
 889: 	if !s.SourceHealthy() {
 890: 		t.Error("expected SourceHealthy true after set")
 891: 	}
 892: }
 893: ```
 894: 
 895: **Step 2: Run test to verify failure**
 896: 
 897: Run:
 898: ```bash
 899: go test ./internal/domain/station/... -v
 900: ```
 901: 
 902: Expected: FAIL with "undefined: Station.ICYName"
 903: 
 904: **Step 3: Implement property accessors**
 905: 
 906: Add to `internal/domain/station/station.go`:
 907: ```go
 908: func (s *Station) ICYName() string {
 909: 	return s.icyName
 910: }
 911: 
 912: func (s *Station) MetaInt() int {
 913: 	return s.metaInt
 914: }
 915: 
 916: func (s *Station) BitrateHint() int {
 917: 	return s.bitrateHint
 918: }
 919: 
 920: func (s *Station) SourceHealthy() bool {
 921: 	return s.sourceHealthy.Load()
 922: }
 923: 
 924: func (s *Station) SetSourceHealthy(healthy bool) {
 925: 	s.sourceHealthy.Store(healthy)
 926: }
 927: ```
 928: 
 929: **Step 4: Run tests to verify pass**
 930: 
 931: Run:
 932: ```bash
 933: go test ./internal/domain/station/... -v
 934: ```
 935: 
 936: Expected: PASS (4 tests)
 937: 
 938: **Step 5: Commit**
 939: 
 940: Run:
 941: ```bash
 942: git add internal/domain/station/
 943: git commit -m "feat: add health status and property accessors to station"
 944: ```
 945: 
 946: ---
 947: 
 948: ## Task 9: HTTP Stream Source Implementation
 949: 
 950: **Files:**
 951: - Create: `internal/infrastructure/source/http.go`
 952: - Create: `internal/infrastructure/source/http_test.go`
 953: 
 954: **Step 1: Write failing test for HTTP stream source**
 955: 
 956: Create `internal/infrastructure/source/http_test.go`:
 957: ```go
 958: // ABOUTME: Tests for HTTP stream source implementation
 959: // ABOUTME: Verifies connection handling and error cases
 960: package source
 961: 
 962: import (
 963: 	"context"
 964: 	"net/http"
 965: 	"net/http/httptest"
 966: 	"testing"
 967: 	"time"
 968: )
 969: 
 970: func TestHTTPSource_Connect(t *testing.T) {
 971: 	// Create test server
 972: 	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 973: 		// Check headers
 974: 		if r.Header.Get("Icy-MetaData") != "0" {
 975: 			t.Errorf("expected Icy-MetaData: 0 header")
 976: 		}
 977: 
 978: 		w.Header().Set("Content-Type", "audio/mpeg")
 979: 		w.WriteHeader(http.StatusOK)
 980: 		w.Write([]byte("audio data"))
 981: 	}))
 982: 	defer server.Close()
 983: 
 984: 	cfg := HTTPConfig{
 985: 		URL:            server.URL,
 986: 		ConnectTimeout: 5 * time.Second,
 987: 		ReadTimeout:    10 * time.Second,
 988: 	}
 989: 
 990: 	src := NewHTTP(cfg)
 991: 
 992: 	ctx := context.Background()
 993: 	reader, err := src.Connect(ctx)
 994: 	if err != nil {
 995: 		t.Fatalf("Connect failed: %v", err)
 996: 	}
 997: 	defer reader.Close()
 998: 
 999: 	buf := make([]byte, 10)
1000: 	n, _ := reader.Read(buf)
1001: 
1002: 	if string(buf[:n]) != "audio data" {
1003: 		t.Errorf("expected 'audio data', got %q", buf[:n])
1004: 	}
1005: }
1006: ```
1007: 
1008: **Step 2: Run test to verify failure**
1009: 
1010: Run:
1011: ```bash
1012: go test ./internal/infrastructure/source/...
1013: ```
1014: 
1015: Expected: FAIL with "no Go files"
1016: 
1017: **Step 3: Write HTTP stream source implementation**
1018: 
1019: Create `internal/infrastructure/source/http.go`:
1020: ```go
1021: // ABOUTME: HTTP stream source implementation for MP3 audio
1022: // ABOUTME: Handles upstream connection with timeouts and proper headers
1023: package source
1024: 
1025: import (
1026: 	"context"
1027: 	"fmt"
1028: 	"io"
1029: 	"net/http"
1030: 	"time"
1031: )
1032: 
1033: type HTTPConfig struct {
1034: 	URL            string
1035: 	ConnectTimeout time.Duration
1036: 	ReadTimeout    time.Duration
1037: 	Headers        map[string]string
1038: }
1039: 
1040: type HTTPSource struct {
1041: 	cfg    HTTPConfig
1042: 	client *http.Client
1043: }
1044: 
1045: func NewHTTP(cfg HTTPConfig) *HTTPSource {
1046: 	transport := &http.Transport{
1047: 		DisableCompression:    true,
1048: 		ExpectContinueTimeout: 1 * time.Second,
1049: 	}
1050: 
1051: 	client := &http.Client{
1052: 		Transport: transport,
1053: 		Timeout:   0, // No total timeout for streaming
1054: 	}
1055: 
1056: 	return &HTTPSource{
1057: 		cfg:    cfg,
1058: 		client: client,
1059: 	}
1060: }
1061: 
1062: func (h *HTTPSource) Connect(ctx context.Context) (io.ReadCloser, error) {
1063: 	req, err := http.NewRequestWithContext(ctx, "GET", h.cfg.URL, nil)
1064: 	if err != nil {
1065: 		return nil, fmt.Errorf("create request: %w", err)
1066: 	}
1067: 
1068: 	// Set ICY headers
1069: 	req.Header.Set("Icy-MetaData", "0")
1070: 
1071: 	// Set custom headers
1072: 	for k, v := range h.cfg.Headers {
1073: 		req.Header.Set(k, v)
1074: 	}
1075: 
1076: 	resp, err := h.client.Do(req)
1077: 	if err != nil {
1078: 		return nil, fmt.Errorf("http request: %w", err)
1079: 	}
1080: 
1081: 	if resp.StatusCode != http.StatusOK {
1082: 		resp.Body.Close()
1083: 		return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
1084: 	}
1085: 
1086: 	return resp.Body, nil
1087: }
1088: ```
1089: 
1090: **Step 4: Run tests to verify pass**
1091: 
1092: Run:
1093: ```bash
1094: go test ./internal/infrastructure/source/... -v
1095: ```
1096: 
1097: Expected: PASS
1098: 
1099: **Step 5: Commit**
1100: 
1101: Run:
1102: ```bash
1103: git add internal/infrastructure/source/
1104: git commit -m "feat: implement HTTP stream source"
1105: ```
1106: 
1107: ---
1108: 
1109: ## Task 10: HTTP Metadata Provider Implementation
1110: 
1111: **Files:**
1112: - Create: `internal/infrastructure/metadata/http.go`
1113: - Create: `internal/infrastructure/metadata/http_test.go`
1114: 
1115: **Step 1: Write failing test for HTTP metadata provider**
1116: 
1117: Create `internal/infrastructure/metadata/http_test.go`:
1118: ```go
1119: // ABOUTME: Tests for HTTP metadata provider implementation
1120: // ABOUTME: Verifies JSON parsing and ICY formatting
1121: package metadata
1122: 
1123: import (
1124: 	"context"
1125: 	"net/http"
1126: 	"net/http/httptest"
1127: 	"testing"
1128: 	"time"
1129: )
1130: 
1131: func TestHTTPProvider_Fetch_JSON(t *testing.T) {
1132: 	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
1133: 		w.Header().Set("Content-Type", "application/json")
1134: 		w.Write([]byte(`{"artist":"Test Artist","title":"Test Song"}`))
1135: 	}))
1136: 	defer server.Close()
1137: 
1138: 	cfg := HTTPConfig{
1139: 		URL:     server.URL,
1140: 		Timeout: 5 * time.Second,
1141: 		Build: BuildConfig{
1142: 			Format: "StreamTitle='{artist} - {title}';",
1143: 		},
1144: 	}
1145: 
1146: 	provider := NewHTTP(cfg)
1147: 
1148: 	ctx := context.Background()
1149: 	result, err := provider.Fetch(ctx)
1150: 	if err != nil {
1151: 		t.Fatalf("Fetch failed: %v", err)
1152: 	}
1153: 
1154: 	expected := "StreamTitle='Test Artist - Test Song';"
1155: 	if result != expected {
1156: 		t.Errorf("expected %q, got %q", expected, result)
1157: 	}
1158: }
1159: ```
1160: 
1161: **Step 2: Run test to verify failure**
1162: 
1163: Run:
1164: ```bash
1165: go test ./internal/infrastructure/metadata/...
1166: ```
1167: 
1168: Expected: FAIL with "no Go files"
1169: 
1170: **Step 3: Write HTTP metadata provider implementation**
1171: 
1172: Create `internal/infrastructure/metadata/http.go`:
1173: ```go
1174: // ABOUTME: HTTP metadata provider implementation with JSON parsing
1175: // ABOUTME: Formats metadata into ICY-compatible strings
1176: package metadata
1177: 
1178: import (
1179: 	"context"
1180: 	"encoding/json"
1181: 	"fmt"
1182: 	"io"
1183: 	"net/http"
1184: 	"strings"
1185: 	"time"
1186: )
1187: 
1188: type BuildConfig struct {
1189: 	Format              string
1190: 	StripSingleQuotes   bool
1191: 	NormalizeWhitespace bool
1192: 	FallbackKeyOrder    []string
1193: }
1194: 
1195: type HTTPConfig struct {
1196: 	URL     string
1197: 	Timeout time.Duration
1198: 	Build   BuildConfig
1199: }
1200: 
1201: type HTTPProvider struct {
1202: 	cfg    HTTPConfig
1203: 	client *http.Client
1204: }
1205: 
1206: func NewHTTP(cfg HTTPConfig) *HTTPProvider {
1207: 	client := &http.Client{
1208: 		Timeout: cfg.Timeout,
1209: 	}
1210: 
1211: 	return &HTTPProvider{
1212: 		cfg:    cfg,
1213: 		client: client,
1214: 	}
1215: }
1216: 
1217: func (h *HTTPProvider) Fetch(ctx context.Context) (string, error) {
1218: 	req, err := http.NewRequestWithContext(ctx, "GET", h.cfg.URL, nil)
1219: 	if err != nil {
1220: 		return "", fmt.Errorf("create request: %w", err)
1221: 	}
1222: 
1223: 	req.Header.Set("Cache-Control", "no-store")
1224: 
1225: 	resp, err := h.client.Do(req)
1226: 	if err != nil {
1227: 		return "", fmt.Errorf("http request: %w", err)
1228: 	}
1229: 	defer resp.Body.Close()
1230: 
1231: 	body, err := io.ReadAll(io.LimitReader(resp.Body, 64*1024))
1232: 	if err != nil {
1233: 		return "", fmt.Errorf("read body: %w", err)
1234: 	}
1235: 
1236: 	// Parse JSON
1237: 	var data map[string]interface{}
1238: 	if err := json.Unmarshal(body, &data); err != nil {
1239: 		return "", fmt.Errorf("parse json: %w", err)
1240: 	}
1241: 
1242: 	// Build ICY string from format template
1243: 	result := h.cfg.Build.Format
1244: 
1245: 	// Simple placeholder replacement
1246: 	result = strings.ReplaceAll(result, "{artist}", getString(data, "artist"))
1247: 	result = strings.ReplaceAll(result, "{title}", getString(data, "title"))
1248: 
1249: 	// Apply transformations
1250: 	if h.cfg.Build.StripSingleQuotes {
1251: 		result = strings.ReplaceAll(result, "'", "")
1252: 	}
1253: 
1254: 	if h.cfg.Build.NormalizeWhitespace {
1255: 		result = strings.Join(strings.Fields(result), " ")
1256: 	}
1257: 
1258: 	return result, nil
1259: }
1260: 
1261: func getString(data map[string]interface{}, key string) string {
1262: 	if val, ok := data[key].(string); ok {
1263: 		return val
1264: 	}
1265: 	return ""
1266: }
1267: ```
1268: 
1269: **Step 4: Run tests to verify pass**
1270: 
1271: Run:
1272: ```bash
1273: go test ./internal/infrastructure/metadata/... -v
1274: ```
1275: 
1276: Expected: PASS
1277: 
1278: **Step 5: Commit**
1279: 
1280: Run:
1281: ```bash
1282: git add internal/infrastructure/metadata/
1283: git commit -m "feat: implement HTTP metadata provider"
1284: ```
1285: 
1286: ---
1287: 
1288: ## Task 11: Config Parsing
1289: 
1290: **Files:**
1291: - Create: `internal/application/config/config.go`
1292: - Create: `internal/application/config/config_test.go`
1293: 
1294: **Step 1: Write failing test for config parsing**
1295: 
1296: Create `internal/application/config/config_test.go`:
1297: ```go
1298: // ABOUTME: Tests for YAML configuration parsing
1299: // ABOUTME: Verifies config structure and validation
1300: package config
1301: 
1302: import (
1303: 	"os"
1304: 	"path/filepath"
1305: 	"testing"
1306: )
1307: 
1308: func TestLoad(t *testing.T) {
1309: 	yamlContent := `
1310: listen:
1311:   host: 0.0.0.0
1312:   port: 8000
1313: 
1314: stations:
1315:   - id: test_station
1316:     icy:
1317:       name: "Test Station"
1318:       metaint: 16384
1319:       bitrate_hint_kbps: 128
1320:     source:
1321:       url: "http://example.com/stream.mp3"
1322:       connect_timeout_ms: 5000
1323:       read_timeout_ms: 15000
1324:     metadata:
1325:       url: "http://example.com/meta"
1326:       poll_ms: 3000
1327:       build:
1328:         format: "StreamTitle='{artist} - {title}';"
1329:     buffering:
1330:       ring_bytes: 262144
1331: `
1332: 
1333: 	tmpDir := t.TempDir()
1334: 	cfgPath := filepath.Join(tmpDir, "config.yaml")
1335: 
1336: 	if err := os.WriteFile(cfgPath, []byte(yamlContent), 0644); err != nil {
1337: 		t.Fatalf("write config: %v", err)
1338: 	}
1339: 
1340: 	cfg, err := Load(cfgPath)
1341: 	if err != nil {
1342: 		t.Fatalf("Load failed: %v", err)
1343: 	}
1344: 
1345: 	if cfg.Listen.Host != "0.0.0.0" {
1346: 		t.Errorf("expected host 0.0.0.0, got %s", cfg.Listen.Host)
1347: 	}
1348: 
1349: 	if cfg.Listen.Port != 8000 {
1350: 		t.Errorf("expected port 8000, got %d", cfg.Listen.Port)
1351: 	}
1352: 
1353: 	if len(cfg.Stations) != 1 {
1354: 		t.Fatalf("expected 1 station, got %d", len(cfg.Stations))
1355: 	}
1356: 
1357: 	st := cfg.Stations[0]
1358: 	if st.ID != "test_station" {
1359: 		t.Errorf("expected ID test_station, got %s", st.ID)
1360: 	}
1361: }
1362: ```
1363: 
1364: **Step 2: Run test to verify failure**
1365: 
1366: Run:
1367: ```bash
1368: go test ./internal/application/config/...
1369: ```
1370: 
1371: Expected: FAIL with "no Go files"
1372: 
1373: **Step 3: Write config implementation**
1374: 
1375: Create `internal/application/config/config.go`:
1376: ```go
1377: // ABOUTME: YAML configuration parsing and validation
1378: // ABOUTME: Defines structure for multi-station proxy configuration
1379: package config
1380: 
1381: import (
1382: 	"fmt"
1383: 	"os"
1384: 
1385: 	"gopkg.in/yaml.v3"
1386: )
1387: 
1388: type Config struct {
1389: 	Listen   ListenConfig     `yaml:"listen"`
1390: 	Stations []StationConfig  `yaml:"stations"`
1391: 	Logging  LoggingConfig    `yaml:"logging"`
1392: }
1393: 
1394: type ListenConfig struct {
1395: 	Host string `yaml:"host"`
1396: 	Port int    `yaml:"port"`
1397: }
1398: 
1399: type StationConfig struct {
1400: 	ID        string          `yaml:"id"`
1401: 	ICY       ICYConfig       `yaml:"icy"`
1402: 	Source    SourceConfig    `yaml:"source"`
1403: 	Metadata  MetadataConfig  `yaml:"metadata"`
1404: 	Buffering BufferingConfig `yaml:"buffering"`
1405: }
1406: 
1407: type ICYConfig struct {
1408: 	Name          string `yaml:"name"`
1409: 	MetaInt       int    `yaml:"metaint"`
1410: 	BitrateHintKbps int  `yaml:"bitrate_hint_kbps"`
1411: }
1412: 
1413: type SourceConfig struct {
1414: 	URL              string            `yaml:"url"`
1415: 	RequestHeaders   map[string]string `yaml:"request_headers"`
1416: 	ConnectTimeoutMs int               `yaml:"connect_timeout_ms"`
1417: 	ReadTimeoutMs    int               `yaml:"read_timeout_ms"`
1418: }
1419: 
1420: type MetadataConfig struct {
1421: 	URL    string      `yaml:"url"`
1422: 	PollMs int         `yaml:"poll_ms"`
1423: 	Build  BuildConfig `yaml:"build"`
1424: }
1425: 
1426: type BuildConfig struct {
1427: 	Format              string   `yaml:"format"`
1428: 	StripSingleQuotes   bool     `yaml:"strip_single_quotes"`
1429: 	Encoding            string   `yaml:"encoding"`
1430: 	NormalizeWhitespace bool     `yaml:"normalize_whitespace"`
1431: 	FallbackKeyOrder    []string `yaml:"fallback_key_order"`
1432: }
1433: 
1434: type BufferingConfig struct {
1435: 	RingBytes            int `yaml:"ring_bytes"`
1436: 	ClientPendingMaxBytes int `yaml:"client_pending_max_bytes"`
1437: }
1438: 
1439: type LoggingConfig struct {
1440: 	Level string `yaml:"level"`
1441: 	JSON  bool   `yaml:"json"`
1442: }
1443: 
1444: func Load(path string) (*Config, error) {
1445: 	data, err := os.ReadFile(path)
1446: 	if err != nil {
1447: 		return nil, fmt.Errorf("read config: %w", err)
1448: 	}
1449: 
1450: 	var cfg Config
1451: 	if err := yaml.Unmarshal(data, &cfg); err != nil {
1452: 		return nil, fmt.Errorf("parse yaml: %w", err)
1453: 	}
1454: 
1455: 	return &cfg, nil
1456: }
1457: ```
1458: 
1459: **Step 4: Run tests to verify pass**
1460: 
1461: Run:
1462: ```bash
1463: go test ./internal/application/config/... -v
1464: ```
1465: 
1466: Expected: PASS
1467: 
1468: **Step 5: Commit**
1469: 
1470: Run:
1471: ```bash
1472: git add internal/application/config/
1473: git commit -m "feat: implement YAML config parsing"
1474: ```
1475: 
1476: ---
1477: 
1478: ## Task 12: Station Manager
1479: 
1480: **Files:**
1481: - Create: `internal/application/manager/manager.go`
1482: - Create: `internal/application/manager/manager_test.go`
1483: 
1484: **Step 1: Write failing test for station manager**
1485: 
1486: Create `internal/application/manager/manager_test.go`:
1487: ```go
1488: // ABOUTME: Tests for station manager lifecycle
1489: // ABOUTME: Verifies station creation and lookup
1490: package manager
1491: 
1492: import (
1493: 	"testing"
1494: 	"time"
1495: 
1496: 	"github.com/harper/radio-metadata-proxy/internal/application/config"
1497: 	"github.com/harper/radio-metadata-proxy/internal/domain/station"
1498: )
1499: 
1500: func TestManager_NewFromConfig(t *testing.T) {
1501: 	cfg := &config.Config{
1502: 		Stations: []config.StationConfig{
1503: 			{
1504: 				ID: "test1",
1505: 				ICY: config.ICYConfig{
1506: 					Name:            "Test 1",
1507: 					MetaInt:         16384,
1508: 					BitrateHintKbps: 128,
1509: 				},
1510: 				Source: config.SourceConfig{
1511: 					URL:              "http://example.com/test1.mp3",
1512: 					ConnectTimeoutMs: 5000,
1513: 				},
1514: 				Metadata: config.MetadataConfig{
1515: 					URL:    "http://example.com/meta1",
1516: 					PollMs: 3000,
1517: 				},
1518: 				Buffering: config.BufferingConfig{
1519: 					RingBytes: 262144,
1520: 				},
1521: 			},
1522: 		},
1523: 	}
1524: 
1525: 	mgr, err := NewFromConfig(cfg)
1526: 	if err != nil {
1527: 		t.Fatalf("NewFromConfig failed: %v", err)
1528: 	}
1529: 
1530: 	if len(mgr.List()) != 1 {
1531: 		t.Errorf("expected 1 station, got %d", len(mgr.List()))
1532: 	}
1533: 
1534: 	st := mgr.Get("test1")
1535: 	if st == nil {
1536: 		t.Fatal("expected to find test1 station")
1537: 	}
1538: 
1539: 	if st.ID() != "test1" {
1540: 		t.Errorf("expected ID test1, got %s", st.ID())
1541: 	}
1542: }
1543: ```
1544: 
1545: **Step 2: Run test to verify failure**
1546: 
1547: Run:
1548: ```bash
1549: go test ./internal/application/manager/...
1550: ```
1551: 
1552: Expected: FAIL with "no Go files"
1553: 
1554: **Step 3: Write station manager implementation**
1555: 
1556: Create `internal/application/manager/manager.go`:
1557: ```go
1558: // ABOUTME: Station manager for lifecycle and lookup
1559: // ABOUTME: Creates stations from config and manages their goroutines
1560: package manager
1561: 
1562: import (
1563: 	"context"
1564: 	"fmt"
1565: 	"sync"
1566: 	"time"
1567: 
1568: 	"github.com/harper/radio-metadata-proxy/internal/application/config"
1569: 	"github.com/harper/radio-metadata-proxy/internal/domain/station"
1570: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/metadata"
1571: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/ring"
1572: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/source"
1573: )
1574: 
1575: type Manager struct {
1576: 	stations map[string]*station.Station
1577: 	mu       sync.RWMutex
1578: 	ctx      context.Context
1579: 	cancel   context.CancelFunc
1580: 	wg       sync.WaitGroup
1581: }
1582: 
1583: func NewFromConfig(cfg *config.Config) (*Manager, error) {
1584: 	ctx, cancel := context.WithCancel(context.Background())
1585: 
1586: 	mgr := &Manager{
1587: 		stations: make(map[string]*station.Station),
1588: 		ctx:      ctx,
1589: 		cancel:   cancel,
1590: 	}
1591: 
1592: 	for _, stCfg := range cfg.Stations {
1593: 		// Create dependencies
1594: 		srcCfg := source.HTTPConfig{
1595: 			URL:            stCfg.Source.URL,
1596: 			ConnectTimeout: time.Duration(stCfg.Source.ConnectTimeoutMs) * time.Millisecond,
1597: 			ReadTimeout:    time.Duration(stCfg.Source.ReadTimeoutMs) * time.Millisecond,
1598: 			Headers:        stCfg.Source.RequestHeaders,
1599: 		}
1600: 		src := source.NewHTTP(srcCfg)
1601: 
1602: 		metaCfg := metadata.HTTPConfig{
1603: 			URL:     stCfg.Metadata.URL,
1604: 			Timeout: time.Duration(stCfg.Metadata.PollMs) * time.Millisecond,
1605: 			Build: metadata.BuildConfig{
1606: 				Format:              stCfg.Metadata.Build.Format,
1607: 				StripSingleQuotes:   stCfg.Metadata.Build.StripSingleQuotes,
1608: 				NormalizeWhitespace: stCfg.Metadata.Build.NormalizeWhitespace,
1609: 				FallbackKeyOrder:    stCfg.Metadata.Build.FallbackKeyOrder,
1610: 			},
1611: 		}
1612: 		metaProv := metadata.NewHTTP(metaCfg)
1613: 
1614: 		buffer := ring.New(stCfg.Buffering.RingBytes)
1615: 
1616: 		// Create station
1617: 		stationCfg := station.Config{
1618: 			ID:             stCfg.ID,
1619: 			ICYName:        stCfg.ICY.Name,
1620: 			MetaInt:        stCfg.ICY.MetaInt,
1621: 			BitrateHint:    stCfg.ICY.BitrateHintKbps,
1622: 			PollInterval:   time.Duration(stCfg.Metadata.PollMs) * time.Millisecond,
1623: 			RingBufferSize: stCfg.Buffering.RingBytes,
1624: 			ChunkBusCap:    32,
1625: 		}
1626: 
1627: 		st := station.New(stationCfg, src, metaProv, buffer)
1628: 
1629: 		mgr.stations[stCfg.ID] = st
1630: 	}
1631: 
1632: 	return mgr, nil
1633: }
1634: 
1635: func (m *Manager) Get(id string) *station.Station {
1636: 	m.mu.RLock()
1637: 	defer m.mu.RUnlock()
1638: 	return m.stations[id]
1639: }
1640: 
1641: func (m *Manager) List() []*station.Station {
1642: 	m.mu.RLock()
1643: 	defer m.mu.RUnlock()
1644: 
1645: 	result := make([]*station.Station, 0, len(m.stations))
1646: 	for _, st := range m.stations {
1647: 		result = append(result, st)
1648: 	}
1649: 	return result
1650: }
1651: 
1652: func (m *Manager) Start() error {
1653: 	m.mu.RLock()
1654: 	defer m.mu.RUnlock()
1655: 
1656: 	for _, st := range m.stations {
1657: 		// TODO: Start station goroutines when implemented
1658: 		_ = st
1659: 	}
1660: 
1661: 	return nil
1662: }
1663: 
1664: func (m *Manager) Shutdown() error {
1665: 	m.cancel()
1666: 	m.wg.Wait()
1667: 	return nil
1668: }
1669: ```
1670: 
1671: **Step 4: Run tests to verify pass**
1672: 
1673: Run:
1674: ```bash
1675: go test ./internal/application/manager/... -v
1676: ```
1677: 
1678: Expected: PASS
1679: 
1680: **Step 5: Commit**
1681: 
1682: Run:
1683: ```bash
1684: git add internal/application/manager/
1685: git commit -m "feat: implement station manager"
1686: ```
1687: 
1688: ---
1689: 
1690: ## Task 13: HTTP Handlers (Part 1 - Stream Handler)
1691: 
1692: **Files:**
1693: - Create: `internal/infrastructure/http/handlers.go`
1694: - Create: `internal/infrastructure/http/handlers_test.go`
1695: 
1696: **Step 1: Write basic test for stream handler structure**
1697: 
1698: Create `internal/infrastructure/http/handlers_test.go`:
1699: ```go
1700: // ABOUTME: Tests for HTTP handlers
1701: // ABOUTME: Verifies routing, headers, and response formats
1702: package http
1703: 
1704: import (
1705: 	"net/http"
1706: 	"net/http/httptest"
1707: 	"testing"
1708: 
1709: 	"github.com/harper/radio-metadata-proxy/internal/application/manager"
1710: 	"github.com/harper/radio-metadata-proxy/internal/application/config"
1711: )
1712: 
1713: func TestStreamHandler_404(t *testing.T) {
1714: 	cfg := &config.Config{
1715: 		Stations: []config.StationConfig{},
1716: 	}
1717: 
1718: 	mgr, _ := manager.NewFromConfig(cfg)
1719: 
1720: 	handler := NewStreamHandler(mgr)
1721: 
1722: 	req := httptest.NewRequest("GET", "/nonexistent/stream", nil)
1723: 	rec := httptest.NewRecorder()
1724: 
1725: 	handler.ServeHTTP(rec, req)
1726: 
1727: 	if rec.Code != http.StatusNotFound {
1728: 		t.Errorf("expected 404, got %d", rec.Code)
1729: 	}
1730: }
1731: ```
1732: 
1733: **Step 2: Run test to verify failure**
1734: 
1735: Run:
1736: ```bash
1737: go test ./internal/infrastructure/http/...
1738: ```
1739: 
1740: Expected: FAIL with "no Go files"
1741: 
1742: **Step 3: Write stream handler implementation**
1743: 
1744: Create `internal/infrastructure/http/handlers.go`:
1745: ```go
1746: // ABOUTME: HTTP handlers for station endpoints
1747: // ABOUTME: Implements stream, metadata, and health check routes
1748: package http
1749: 
1750: import (
1751: 	"encoding/json"
1752: 	"fmt"
1753: 	"net/http"
1754: 	"strings"
1755: 
1756: 	"github.com/harper/radio-metadata-proxy/internal/application/manager"
1757: )
1758: 
1759: type StreamHandler struct {
1760: 	mgr *manager.Manager
1761: }
1762: 
1763: func NewStreamHandler(mgr *manager.Manager) *StreamHandler {
1764: 	return &StreamHandler{mgr: mgr}
1765: }
1766: 
1767: func (h *StreamHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
1768: 	// Extract station ID from path: /{station}/stream
1769: 	parts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
1770: 	if len(parts) != 2 || parts[1] != "stream" {
1771: 		http.NotFound(w, r)
1772: 		return
1773: 	}
1774: 
1775: 	stationID := parts[0]
1776: 	st := h.mgr.Get(stationID)
1777: 	if st == nil {
1778: 		http.NotFound(w, r)
1779: 		return
1780: 	}
1781: 
1782: 	// Set ICY headers
1783: 	w.Header().Set("Content-Type", "audio/mpeg")
1784: 	w.Header().Set("icy-name", st.ICYName())
1785: 	w.Header().Set("icy-br", fmt.Sprintf("%d", st.BitrateHint()))
1786: 	w.Header().Set("icy-metaint", fmt.Sprintf("%d", st.MetaInt()))
1787: 	w.Header().Set("Cache-Control", "no-store")
1788: 	w.Header().Set("Connection", "close")
1789: 
1790: 	// TODO: Implement actual streaming when station goroutines are ready
1791: 	w.WriteHeader(http.StatusOK)
1792: }
1793: 
1794: type MetaHandler struct {
1795: 	mgr *manager.Manager
1796: }
1797: 
1798: func NewMetaHandler(mgr *manager.Manager) *MetaHandler {
1799: 	return &MetaHandler{mgr: mgr}
1800: }
1801: 
1802: func (h *MetaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
1803: 	parts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
1804: 	if len(parts) != 2 || parts[1] != "meta" {
1805: 		http.NotFound(w, r)
1806: 		return
1807: 	}
1808: 
1809: 	stationID := parts[0]
1810: 	st := h.mgr.Get(stationID)
1811: 	if st == nil {
1812: 		http.NotFound(w, r)
1813: 		return
1814: 	}
1815: 
1816: 	type response struct {
1817: 		Current      string  `json:"current"`
1818: 		UpdatedAt    *string `json:"updated_at,omitempty"`
1819: 		SourceHealthy bool   `json:"sourceHealthy"`
1820: 	}
1821: 
1822: 	var updatedAt *string
1823: 	if t := st.LastMetadataUpdate(); t != nil {
1824: 		s := t.Format("2006-01-02T15:04:05Z07:00")
1825: 		updatedAt = &s
1826: 	}
1827: 
1828: 	resp := response{
1829: 		Current:      st.CurrentMetadata(),
1830: 		UpdatedAt:    updatedAt,
1831: 		SourceHealthy: st.SourceHealthy(),
1832: 	}
1833: 
1834: 	w.Header().Set("Content-Type", "application/json")
1835: 	json.NewEncoder(w).Encode(resp)
1836: }
1837: 
1838: type StationsHandler struct {
1839: 	mgr *manager.Manager
1840: }
1841: 
1842: func NewStationsHandler(mgr *manager.Manager) *StationsHandler {
1843: 	return &StationsHandler{mgr: mgr}
1844: }
1845: 
1846: func (h *StationsHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
1847: 	type stationInfo struct {
1848: 		ID            string `json:"id"`
1849: 		StreamURL     string `json:"stream_url"`
1850: 		MetaURL       string `json:"meta_url"`
1851: 		Clients       int    `json:"clients"`
1852: 		SourceHealthy bool   `json:"sourceHealthy"`
1853: 	}
1854: 
1855: 	stations := h.mgr.List()
1856: 	result := make([]stationInfo, 0, len(stations))
1857: 
1858: 	for _, st := range stations {
1859: 		result = append(result, stationInfo{
1860: 			ID:            st.ID(),
1861: 			StreamURL:     fmt.Sprintf("/%s/stream", st.ID()),
1862: 			MetaURL:       fmt.Sprintf("/%s/meta", st.ID()),
1863: 			Clients:       st.ClientCount(),
1864: 			SourceHealthy: st.SourceHealthy(),
1865: 		})
1866: 	}
1867: 
1868: 	w.Header().Set("Content-Type", "application/json")
1869: 	json.NewEncoder(w).Encode(result)
1870: }
1871: 
1872: func HealthzHandler(w http.ResponseWriter, r *http.Request) {
1873: 	type response struct {
1874: 		OK bool `json:"ok"`
1875: 	}
1876: 
1877: 	w.Header().Set("Content-Type", "application/json")
1878: 	json.NewEncoder(w).Encode(response{OK: true})
1879: }
1880: ```
1881: 
1882: **Step 4: Run tests to verify pass**
1883: 
1884: Run:
1885: ```bash
1886: go test ./internal/infrastructure/http/... -v
1887: ```
1888: 
1889: Expected: PASS
1890: 
1891: **Step 5: Commit**
1892: 
1893: Run:
1894: ```bash
1895: git add internal/infrastructure/http/
1896: git commit -m "feat: implement HTTP handlers for streaming and metadata"
1897: ```
1898: 
1899: ---
1900: 
1901: ## Task 14: Main Entry Point
1902: 
1903: **Files:**
1904: - Create: `cmd/icyproxy/main.go`
1905: 
1906: **Step 1: Write main.go**
1907: 
1908: Create `cmd/icyproxy/main.go`:
1909: ```go
1910: // ABOUTME: Main entry point for ICY metadata proxy
1911: // ABOUTME: Loads config, starts stations, runs HTTP server
1912: package main
1913: 
1914: import (
1915: 	"context"
1916: 	"fmt"
1917: 	"log"
1918: 	"net"
1919: 	nethttp "net/http"
1920: 	"os"
1921: 	"os/signal"
1922: 	"syscall"
1923: 	"time"
1924: 
1925: 	"github.com/harper/radio-metadata-proxy/internal/application/config"
1926: 	"github.com/harper/radio-metadata-proxy/internal/application/manager"
1927: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/http"
1928: )
1929: 
1930: func main() {
1931: 	if err := run(); err != nil {
1932: 		log.Fatalf("fatal: %v", err)
1933: 	}
1934: }
1935: 
1936: func run() error {
1937: 	// Load config
1938: 	cfgPath := "config.yaml"
1939: 	if len(os.Args) > 1 {
1940: 		cfgPath = os.Args[1]
1941: 	}
1942: 
1943: 	cfg, err := config.Load(cfgPath)
1944: 	if err != nil {
1945: 		return fmt.Errorf("load config: %w", err)
1946: 	}
1947: 
1948: 	// Create station manager
1949: 	mgr, err := manager.NewFromConfig(cfg)
1950: 	if err != nil {
1951: 		return fmt.Errorf("create manager: %w", err)
1952: 	}
1953: 
1954: 	// Start stations
1955: 	if err := mgr.Start(); err != nil {
1956: 		return fmt.Errorf("start stations: %w", err)
1957: 	}
1958: 
1959: 	// Setup HTTP routes
1960: 	mux := nethttp.NewServeMux()
1961: 	mux.Handle("/stations", http.NewStationsHandler(mgr))
1962: 	mux.HandleFunc("/healthz", http.HealthzHandler)
1963: 
1964: 	// Station-specific routes
1965: 	streamHandler := http.NewStreamHandler(mgr)
1966: 	metaHandler := http.NewMetaHandler(mgr)
1967: 
1968: 	mux.HandleFunc("/", func(w nethttp.ResponseWriter, r *nethttp.Request) {
1969: 		if len(r.URL.Path) > 1 && r.URL.Path[len(r.URL.Path)-7:] == "/stream" {
1970: 			streamHandler.ServeHTTP(w, r)
1971: 			return
1972: 		}
1973: 		if len(r.URL.Path) > 1 && r.URL.Path[len(r.URL.Path)-5:] == "/meta" {
1974: 			metaHandler.ServeHTTP(w, r)
1975: 			return
1976: 		}
1977: 		nethttp.NotFound(w, r)
1978: 	})
1979: 
1980: 	// Create HTTP server
1981: 	addr := fmt.Sprintf("%s:%d", cfg.Listen.Host, cfg.Listen.Port)
1982: 	srv := &nethttp.Server{
1983: 		Addr:         addr,
1984: 		Handler:      mux,
1985: 		ReadTimeout:  15 * time.Second,
1986: 		WriteTimeout: 0, // Streaming
1987: 		IdleTimeout:  0, // Streaming
1988: 		BaseContext: func(_ net.Listener) context.Context {
1989: 			return context.Background()
1990: 		},
1991: 	}
1992: 
1993: 	// Graceful shutdown
1994: 	shutdown := make(chan error, 1)
1995: 	go func() {
1996: 		sigint := make(chan os.Signal, 1)
1997: 		signal.Notify(sigint, os.Interrupt, syscall.SIGTERM)
1998: 		<-sigint
1999: 
2000: 		log.Println("shutting down...")
2001: 
2002: 		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
2003: 		defer cancel()
2004: 
2005: 		shutdown <- srv.Shutdown(ctx)
2006: 	}()
2007: 
2008: 	// Start server
2009: 	log.Printf("listening on http://%s (try /stations)", addr)
2010: 	if err := srv.ListenAndServe(); err != nil && err != nethttp.ErrServerClosed {
2011: 		return fmt.Errorf("http server: %w", err)
2012: 	}
2013: 
2014: 	// Wait for shutdown
2015: 	if err := <-shutdown; err != nil {
2016: 		return fmt.Errorf("shutdown: %w", err)
2017: 	}
2018: 
2019: 	// Shutdown stations
2020: 	if err := mgr.Shutdown(); err != nil {
2021: 		return fmt.Errorf("shutdown stations: %w", err)
2022: 	}
2023: 
2024: 	log.Println("shutdown complete")
2025: 	return nil
2026: }
2027: ```
2028: 
2029: **Step 2: Commit**
2030: 
2031: Run:
2032: ```bash
2033: git add cmd/icyproxy/
2034: git commit -m "feat: add main entry point with HTTP server"
2035: ```
2036: 
2037: ---
2038: 
2039: ## Task 15: Example Config
2040: 
2041: **Files:**
2042: - Create: `configs/example.yaml`
2043: 
2044: **Step 1: Write example config**
2045: 
2046: Create `configs/example.yaml`:
2047: ```yaml
2048: listen:
2049:   host: 0.0.0.0
2050:   port: 8000
2051: 
2052: stations:
2053:   - id: "fip"
2054:     icy:
2055:       name: "FIP (proxy)"
2056:       metaint: 16384
2057:       bitrate_hint_kbps: 128
2058:     source:
2059:       url: "https://icecast.radiofrance.fr/fip-hifi.aac"
2060:       request_headers:
2061:         Icy-MetaData: "0"
2062:       connect_timeout_ms: 5000
2063:       read_timeout_ms: 15000
2064:     metadata:
2065:       url: "https://fip-metadata.fly.dev/"
2066:       poll_ms: 3000
2067:       build:
2068:         format: "StreamTitle='{artist} - {title}';"
2069:         strip_single_quotes: true
2070:         normalize_whitespace: true
2071:     buffering:
2072:       ring_bytes: 262144
2073: 
2074:   - id: "nts"
2075:     icy:
2076:       name: "NTS Radio 1 (proxy)"
2077:       metaint: 16384
2078:       bitrate_hint_kbps: 128
2079:     source:
2080:       url: "https://stream-mixtape-geo.ntslive.net/stream"
2081:       request_headers:
2082:         Icy-MetaData: "0"
2083:       connect_timeout_ms: 5000
2084:       read_timeout_ms: 15000
2085:     metadata:
2086:       url: "https://www.nts.live/api/v2/live"
2087:       poll_ms: 5000
2088:       build:
2089:         format: "StreamTitle='{artist} - {title}';"
2090:         strip_single_quotes: true
2091:         normalize_whitespace: true
2092:     buffering:
2093:       ring_bytes: 262144
2094: 
2095: logging:
2096:   level: info
2097:   json: false
2098: ```
2099: 
2100: **Step 2: Commit**
2101: 
2102: Run:
2103: ```bash
2104: git add configs/
2105: git commit -m "feat: add example configuration for FIP and NTS"
2106: ```
2107: 
2108: ---
2109: 
2110: ## Task 16: Dockerfile
2111: 
2112: **Files:**
2113: - Create: `Dockerfile`
2114: - Create: `.dockerignore`
2115: 
2116: **Step 1: Write Dockerfile**
2117: 
2118: Create `Dockerfile`:
2119: ```dockerfile
2120: # Build stage
2121: FROM golang:1.23-alpine AS builder
2122: 
2123: WORKDIR /app
2124: 
2125: # Copy go mod files
2126: COPY go.mod go.sum ./
2127: RUN go mod download
2128: 
2129: # Copy source
2130: COPY . .
2131: 
2132: # Build binary
2133: RUN CGO_ENABLED=0 GOOS=linux go build -o icyproxy ./cmd/icyproxy
2134: 
2135: # Runtime stage
2136: FROM alpine:latest
2137: 
2138: RUN apk --no-cache add ca-certificates
2139: 
2140: WORKDIR /app
2141: 
2142: COPY --from=builder /app/icyproxy .
2143: COPY configs/example.yaml /etc/icyproxy/config.yaml
2144: 
2145: EXPOSE 8000
2146: 
2147: CMD ["./icyproxy", "/etc/icyproxy/config.yaml"]
2148: ```
2149: 
2150: **Step 2: Write .dockerignore**
2151: 
2152: Create `.dockerignore`:
2153: ```
2154: .git
2155: .gitignore
2156: README.md
2157: docs/
2158: *.md
2159: .vscode
2160: .idea
2161: ```
2162: 
2163: **Step 3: Commit**
2164: 
2165: Run:
2166: ```bash
2167: git add Dockerfile .dockerignore
2168: git commit -m "feat: add Dockerfile for multi-stage build"
2169: ```
2170: 
2171: ---
2172: 
2173: ## Task 17: README
2174: 
2175: **Files:**
2176: - Modify: `README.md`
2177: 
2178: **Step 1: Write README**
2179: 
2180: Update `README.md`:
2181: ```markdown
2182: # Radio Metadata Proxy
2183: 
2184: Multi-station ICY metadata proxy for streaming radio with custom metadata injection.
2185: 
2186: ## Features
2187: 
2188: - Multiple stations from single daemon
2189: - ICY metadata injection (Shoutcast/Icecast compatible)
2190: - Ring buffer for stream smoothing
2191: - Automatic reconnection with backoff
2192: - Clean hexagonal architecture
2193: 
2194: ## Quick Start
2195: 
2196: ### Binary
2197: 
2198: ```bash
2199: go build -o icyproxy ./cmd/icyproxy
2200: ./icyproxy configs/example.yaml
2201: ```
2202: 
2203: ### Docker
2204: 
2205: ```bash
2206: docker build -t icyproxy .
2207: docker run -p 8000:8000 -v ./myconfig.yaml:/etc/icyproxy/config.yaml icyproxy
2208: ```
2209: 
2210: ## Usage
2211: 
2212: ### Endpoints
2213: 
2214: - `GET /{station}/stream` - ICY stream
2215: - `GET /{station}/meta` - JSON metadata
2216: - `GET /stations` - List all stations
2217: - `GET /healthz` - Health check
2218: 
2219: ### Example
2220: 
2221: ```bash
2222: # List stations
2223: curl http://localhost:8000/stations
2224: 
2225: # Stream audio (VLC, mpv, etc)
2226: mpv http://localhost:8000/fip/stream
2227: 
2228: # Get metadata
2229: curl http://localhost:8000/fip/meta
2230: ```
2231: 
2232: ## Configuration
2233: 
2234: See `configs/example.yaml` for full configuration options.
2235: 
2236: ## Architecture
2237: 
2238: - **Domain Layer**: Station model, interfaces
2239: - **Application Layer**: Manager, config
2240: - **Infrastructure Layer**: HTTP implementations, ICY encoding, ring buffer
2241: 
2242: ## License
2243: 
2244: MIT
2245: ```
2246: 
2247: **Step 2: Commit**
2248: 
2249: Run:
2250: ```bash
2251: git add README.md
2252: git commit -m "docs: add README with usage instructions"
2253: ```
2254: 
2255: ---
2256: 
2257: ## Next Steps
2258: 
2259: **All v1 minimal features are now implemented!**
2260: 
2261: What's NOT yet implemented (but designed for):
2262: - Station goroutines (source reader, metadata poller) - need to add Start/Stop methods
2263: - Actual streaming with ICY injection in client handlers
2264: - Client backpressure management
2265: 
2266: **To complete v1, you'll need to:**
2267: 1. Implement `Station.Start()` method with 3 goroutines
2268: 2. Implement actual streaming in `StreamHandler`
2269: 3. Add client writer with ICY injection logic
2270: 4. Test with real audio streams
2271: 
2272: These are the core runtime pieces that tie everything together. The architecture is ready!
</file>

<file path="docs/spec.md">
  1: # Local ICY Metadata Proxy — Multi-Station Spec (v1.1)
  2: 
  3: ## Core idea
  4: 
  5: * Run one daemon that hosts multiple stations.
  6: * Each station has its own upstream audio URL, metadata URL, buffer, and state.
  7: * HTTP path routes select the station:
  8: 
  9:   * `/fip/stream`, `/fip/meta`
 10:   * `/fip_hiphop/stream`, `/fip_hiphop/meta`
 11:   * Add as many as you like.
 12: 
 13: ## Station model
 14: 
 15: For each `station`:
 16: 
 17: * `id` (URL-safe, used in routes)
 18: * `source.url` (MP3 stream)
 19: * `metadata.url` (JSON/whatever you fetch)
 20: * `icy.metaint` (default per station; can differ)
 21: * `buffering` + `reconnect` policy (per station)
 22: * live state: `currentMeta`, `updatedAt`, `ringBuffer`, `clients[]`, `sourceConnected`
 23: 
 24: All stations share the same binary/process but **do not** share readers/buffers.
 25: 
 26: ## Routing
 27: 
 28: * `GET /:station/stream` → ICY stream for that station.
 29: * `GET /:station/meta` → JSON now-playing for that station.
 30: * `GET /:station/healthz` → station health JSON.
 31: * `GET /stations` → list of station IDs + minimal status.
 32: * `GET /healthz` → aggregate (all stations).
 33: 
 34: Return `404` for unknown `:station`.
 35: 
 36: ## Concurrency model
 37: 
 38: * One `SourceReader` goroutine/task per station.
 39: * One `MetadataPoller` per station.
 40: * Fan-out per station: station-scoped event bus + ring buffer.
 41: * Client sessions attach to the selected station only.
 42: 
 43: ## Config (YAML)
 44: 
 45: ```yaml
 46: listen:
 47:   host: 0.0.0.0
 48:   port: 8000
 49: 
 50: stations:
 51:   - id: "fip"
 52:     icy:
 53:       name: "FIP (proxy)"
 54:       metaint: 16384
 55:       bitrate_hint_kbps: 128
 56:     source:
 57:       url: "https://audio.example/fip.mp3"
 58:       request_headers: { Icy-MetaData: "0" }
 59:       connect_timeout_ms: 5000
 60:       read_timeout_ms: 15000
 61:       reconnect: { backoff_initial_ms: 1000, backoff_max_ms: 30000 }
 62:     metadata:
 63:       url: "https://fip-metadata.fly.dev/"
 64:       poll_ms: 3000
 65:       stale_ttl_ms: 300000
 66:       build:
 67:         format: "StreamTitle='{artist} - {title}';"
 68:         strip_single_quotes: true
 69:         encoding: "iso-8859-1"
 70:         normalize_whitespace: true
 71:         fallback_key_order: ["title", "track.title"]
 72:     buffering:
 73:       ring_bytes: 262144
 74:       client_pending_max_bytes: 262144
 75: 
 76:   - id: "fip_hiphop"
 77:     icy:
 78:       name: "FIP Hip-Hop (proxy)"
 79:       metaint: 16384
 80:       bitrate_hint_kbps: 128
 81:     source:
 82:       url: "https://audio.example/fip_hiphop.mp3"
 83:       request_headers: { Icy-MetaData: "0" }
 84:       connect_timeout_ms: 5000
 85:       read_timeout_ms: 15000
 86:       reconnect: { backoff_initial_ms: 1000, backoff_max_ms: 30000 }
 87:     metadata:
 88:       url: "https://fip-metadata.fly.dev/hiphop"   # if different; else reuse
 89:       poll_ms: 3000
 90:       stale_ttl_ms: 300000
 91:       build:
 92:         format: "StreamTitle='{artist} - {title}';"
 93:         strip_single_quotes: true
 94:         encoding: "iso-8859-1"
 95:         normalize_whitespace: true
 96:         fallback_key_order: ["title", "track.title"]
 97:     buffering:
 98:       ring_bytes: 262144
 99:       client_pending_max_bytes: 262144
100: 
101: logging:
102:   level: info
103:   json: false
104: 
105: http:
106:   headers: {}
107:   # optional basic auth (if exposing beyond localhost)
108:   # auth:
109:   #   type: basic
110:   #   users:
111:   #     - username: "harper"
112:   #       password: "hunter2"
113: ```
114: 
115: ## Endpoints (per station)
116: 
117: * `/fip/stream` → `Content-Type: audio/mpeg`, `icy-metaint: 16384`, ICY blocks injected
118: * `/fip/meta` → `{current, updated_at, raw}`
119: * `/fip/healthz` → `{sourceConnected, clients, ring_fill_bytes, lastMetaAt}`
120: * `/stations` → `[{id, sourceConnected, clients}]`
121: * `/healthz` → `{ok: bool, stations: {...}}`
122: 
123: ## ICY injection (unchanged)
124: 
125: * After each `metaInt` audio bytes, write 1-byte length + padded metadata payload (16-byte blocks).
126: * Max payload 4080 bytes; truncate earlier (e.g., 512B) in practice.
127: 
128: ## Metadata logic (per station)
129: 
130: * Poll on interval; normalize; only update when value changes.
131: * Debounce 1 cycle to avoid flaps.
132: * On endpoint failure, keep last value until `stale_ttl_ms`, then send empty metadata blocks.
133: 
134: ## Resilience (per station)
135: 
136: * Reconnect with exponential backoff on source failure; keep clients attached.
137: * No silence synthesis (v1.1); clients stall until bytes resume.
138: * Ring buffer (~256 KB) smooths hiccups; new clients start at live head.
139: 
140: ## Backpressure
141: 
142: * Each client has a bounded pending queue; if over limit or slow, drop the client.
143: * Station fan-out is non-blocking; slow clients don’t stall others.
144: 
145: ## Security
146: 
147: * Default bind `127.0.0.1`.
148: * If binding LAN, consider basic auth or a simple HMAC token on `/stream`.
149: 
150: ## Observability
151: 
152: * Logs include `station_id` for every event.
153: * Per-station counters: `clients_current`, `source_disconnects`, `metadata_failures`.
154: * Gauges: `ring_fill_bytes`, `client_pending_max`.
155: 
156: ## Performance targets (multi-station)
157: 
158: * With 2–4 stations, ~10 clients total @128kbps: <10% CPU, <128MB RSS on a modest box.
159: 
160: ## Testing matrix (multi-station)
161: 
162: * Parallel source disconnects: one station drops, others unaffected.
163: * Metadata update skew: one station flaps; others stable.
164: * Slow client on `/fip_hiphop` doesn’t impact `/fip`.
165: * Unknown route `/nope/stream` → 404.
166: 
167: ## Directory layout
168: 
169: ```
170: /cmd/metadata-proxy/main.(js|go)
171: /internal/config/...
172: /internal/station/manager.(js|go)      # creates N stations from config
173: /internal/station/instance.(js|go)     # SourceReader, Poller, Fanout
174: /internal/icy/block.(js|go)
175: /internal/http/router.(js|go)
176: /configs/example.yaml
177: ```
178: 
179: ## Minimal route map (what you asked for)
180: 
181: * `/fip/stream` → fip
182: * `/fip_hiphop/stream` → fip_hiphop
183: * same for `/meta`, `/healthz`.
</file>

<file path="docs/started.md">
  1: Go. For this kind of long-running, low-latency byte shoveling with per-client state, Go’s goroutines + channels + zero-dependency static binary beat Node’s event loop and package bloat. You’ll get steadier memory, simpler deploy (single binary), and easier concurrency (one goroutine per station + per client). Node only wins if you want to hack fast in JS or reuse existing web code.
  2: 
  3: Here’s a tight Go starter that matches your multi-station spec. It’s a single file so you can feel the shape; expand into packages later.
  4: 
  5: ```go
  6: // cmd/icyproxy/main.go
  7: // go 1.22+
  8: // Minimal multi-station ICY proxy: MP3 passthrough + ICY metadata injection.
  9: // - Path routing: /{station}/stream, /{station}/meta, /stations, /healthz
 10: // - One SourceReader + MetadataPoller per station
 11: // - Very small ring buffer to smooth hiccups
 12: //
 13: // Build: go build -o icyproxy ./cmd/icyproxy
 14: // Run:   ./icyproxy
 15: //
 16: // NOTE: This is a compact starter; productionize by:
 17: // - moving to packages, YAML config, better logging, timeouts, auth, metrics.
 18: 
 19: package main
 20: 
 21: import (
 22: 	"bytes"
 23: 	"context"
 24: 	"encoding/json"
 25: 	"errors"
 26: 	"fmt"
 27: 	"io"
 28: 	"log"
 29: 	"net"
 30: 	"net/http"
 31: 	"strings"
 32: 	"sync"
 33: 	"sync/atomic"
 34: 	"time"
 35: )
 36: 
 37: const (
 38: 	defaultMetaInt     = 16384
 39: 	ringBytes          = 256 * 1024
 40: 	clientPendingLimit = 256 * 1024
 41: 	metadataPollEvery  = 3 * time.Second
 42: 	staleTTL           = 5 * time.Minute
 43: 	listenAddr         = "127.0.0.1:8000" // change to 0.0.0.0 for LAN
 44: )
 45: 
 46: // ---- Station model ----
 47: 
 48: type Station struct {
 49: 	ID            string
 50: 	ICYName       string
 51: 	MetaInt       int
 52: 	BitrateHint   int
 53: 	SourceURL     string
 54: 	MetadataURL   string
 55: 	srcClient     *http.Client
 56: 	metaClient    *http.Client
 57: 	ring          *Ring
 58: 	clients       map[*Client]struct{}
 59: 	muClients     sync.Mutex
 60: 	chunkBus      chan []byte
 61: 	sourceOK      atomic.Bool
 62: 	curMeta       atomic.Pointer[string]
 63: 	lastMetaAt    atomic.Pointer[time.Time]
 64: 	stop          context.CancelFunc
 65: 	reconnectBack time.Duration
 66: }
 67: 
 68: type Client struct {
 69: 	w          http.ResponseWriter
 70: 	flusher    http.Flusher
 71: 	bytesToMet int
 72: 	pending    int
 73: 	closed     atomic.Bool
 74: 	station    *Station
 75: }
 76: 
 77: // ---- Minimal ring buffer for smoothing hiccups ----
 78: 
 79: type Ring struct {
 80: 	buf []byte
 81: 	w   int
 82: 	n   int
 83: 	mu  sync.Mutex
 84: }
 85: 
 86: func NewRing(sz int) *Ring { return &Ring{buf: make([]byte, sz)} }
 87: 
 88: // Write appends bytes (drop oldest on overflow).
 89: func (r *Ring) Write(p []byte) {
 90: 	r.mu.Lock()
 91: 	defer r.mu.Unlock()
 92: 	for len(p) > 0 {
 93: 		space := len(r.buf) - r.n
 94: 		if space == 0 {
 95: 			// drop 1/4 oldest to make room
 96: 			drop := len(r.buf) / 4
 97: 			r.w = (r.w + drop) % len(r.buf)
 98: 			r.n -= drop
 99: 			if r.n < 0 {
100: 				r.n = 0
101: 			}
102: 			space = len(r.buf) - r.n
103: 		}
104: 		chunk := min(space, len(p))
105: 		end := (r.w + r.n) % len(r.buf)
106: 		right := min(chunk, len(r.buf)-end)
107: 		copy(r.buf[end:end+right], p[:right])
108: 		if right < chunk {
109: 			copy(r.buf[0:chunk-right], p[right:chunk])
110: 		}
111: 		r.n += chunk
112: 		p = p[chunk:]
113: 	}
114: }
115: 
116: // Snapshot returns a contiguous copy of current buffer head..tail.
117: func (r *Ring) Snapshot() []byte {
118: 	r.mu.Lock()
119: 	defer r.mu.Unlock()
120: 	out := make([]byte, r.n)
121: 	if r.n == 0 {
122: 		return out
123: 	}
124: 	head := r.w
125: 	tail := (r.w + r.n) % len(r.buf)
126: 	if head < tail {
127: 		copy(out, r.buf[head:tail])
128: 	} else {
129: 		copy(out, r.buf[head:])
130: 		copy(out[len(r.buf)-head:], r.buf[:tail])
131: 	}
132: 	return out
133: }
134: 
135: // ---- Station runtime ----
136: 
137: func (s *Station) Start(ctx context.Context, wg *sync.WaitGroup) {
138: 	ctx, cancel := context.WithCancel(ctx)
139: 	s.stop = cancel
140: 	wg.Add(2)
141: 	go func() { defer wg.Done(); s.runSource(ctx) }()
142: 	go func() { defer wg.Done(); s.runMetadata(ctx) }()
143: }
144: 
145: func (s *Station) runSource(ctx context.Context) {
146: 	backoff := 1 * time.Second
147: 	for {
148: 		req, _ := http.NewRequestWithContext(ctx, "GET", s.SourceURL, nil)
149: 		req.Header.Set("Icy-MetaData", "0")
150: 		resp, err := s.srcClient.Do(req)
151: 		if err != nil || resp.StatusCode != 200 {
152: 			log.Printf("[%s] source connect failed: %v (code=%v)", s.ID, err, statusCode(resp))
153: 			if resp != nil && resp.Body != nil {
154: 				resp.Body.Close()
155: 			}
156: 			select {
157: 			case <-time.After(backoff):
158: 			case <-ctx.Done():
159: 				return
160: 			}
161: 			backoff = minDur(backoff*2, 30*time.Second)
162: 			continue
163: 		}
164: 		log.Printf("[%s] source connected", s.ID)
165: 		s.sourceOK.Store(true)
166: 		backoff = 1 * time.Second
167: 		r := resp.Body
168: 		buf := make([]byte, 32*1024)
169: 		for {
170: 			n, e := r.Read(buf)
171: 			if n > 0 {
172: 				chunk := buf[:n]
173: 				// write to ring (for smoothing) and broadcast
174: 				s.ring.Write(chunk)
175: 				select {
176: 				case s.chunkBus <- chunk:
177: 				default:
178: 					// if bus is full, drop chunk (protect producer)
179: 				}
180: 			}
181: 			if e != nil {
182: 				if !errors.Is(e, io.EOF) {
183: 					log.Printf("[%s] source read error: %v", s.ID, e)
184: 				}
185: 				break
186: 			}
187: 			if ctx.Err() != nil {
188: 				break
189: 			}
190: 		}
191: 		s.sourceOK.Store(false)
192: 		resp.Body.Close()
193: 		log.Printf("[%s] source disconnected", s.ID)
194: 		select {
195: 		case <-time.After(backoff):
196: 		case <-ctx.Done():
197: 			return
198: 		}
199: 		backoff = minDur(backoff*2, 30*time.Second)
200: 	}
201: }
202: 
203: func (s *Station) runMetadata(ctx context.Context) {
204: 	var last string
205: 	ticker := time.NewTicker(metadataPollEvery)
206: 	defer ticker.Stop()
207: 	for {
208: 		_ = s.fetchAndSetMeta(&last)
209: 		select {
210: 		case <-ticker.C:
211: 		case <-ctx.Done():
212: 			return
213: 		}
214: 	}
215: }
216: 
217: func (s *Station) fetchAndSetMeta(last *string) error {
218: 	req, _ := http.NewRequest("GET", s.MetadataURL, nil)
219: 	req.Header.Set("Cache-Control", "no-store")
220: 	resp, err := s.metaClient.Do(req)
221: 	if err != nil {
222: 		return err
223: 	}
224: 	defer resp.Body.Close()
225: 	body, _ := io.ReadAll(io.LimitReader(resp.Body, 64*1024))
226: 	title := parseTitle(body) // flexible JSON/text parse
227: 	title = normalizeTitle(title)
228: 	icy := fmt.Sprintf("StreamTitle='%s';", sanitizeQuotes(title))
229: 	if icy != *last && icy != "StreamTitle='';" {
230: 		s.curMeta.Store(&icy)
231: 		now := time.Now()
232: 		s.lastMetaAt.Store(&now)
233: 		*last = icy
234: 		log.Printf("[%s] meta: %s", s.ID, title)
235: 	}
236: 	return nil
237: }
238: 
239: // ---- HTTP handlers ----
240: 
241: func (s *Station) handleStream(w http.ResponseWriter, r *http.Request) {
242: 	// headers: ICY-compatible
243: 	h := w.Header()
244: 	h.Set("Content-Type", "audio/mpeg")
245: 	h.Set("icy-name", s.ICYName)
246: 	h.Set("icy-br", fmt.Sprintf("%d", s.BitrateHint))
247: 	h.Set("icy-metaint", fmt.Sprintf("%d", s.MetaInt))
248: 	// Some clients care less about status line; Go will send HTTP/1.1 200 OK.
249: 	if f, ok := w.(http.Flusher); ok {
250: 		f.Flush()
251: 	}
252: 
253: 	c := &Client{
254: 		w:          w,
255: 		flusher:    w.(http.Flusher),
256: 		bytesToMet: s.MetaInt,
257: 		station:    s,
258: 	}
259: 	s.addClient(c)
260: 	defer s.removeClient(c)
261: 
262: 	notify := r.Context().Done()
263: 	// Start by sending nothing from ring (live only, simpler).
264: 	// If you want, you can write s.ring.Snapshot() here.
265: 
266: 	for {
267: 		select {
268: 		case chunk := <-s.chunkBus:
269: 			if c.closed.Load() {
270: 				return
271: 			}
272: 			if err := c.writeWithICY(chunk); err != nil {
273: 				return
274: 			}
275: 		case <-notify:
276: 			return
277: 		}
278: 	}
279: }
280: 
281: func (s *Station) handleMeta(w http.ResponseWriter, _ *http.Request) {
282: 	type resp struct {
283: 		Current   string     `json:"current"`
284: 		UpdatedAt *time.Time `json:"updated_at,omitempty"`
285: 		SourceOK  bool       `json:"sourceConnected"`
286: 	}
287: 	cur := ""
288: 	if p := s.curMeta.Load(); p != nil {
289: 		cur = *p
290: 	}
291: 	var at *time.Time
292: 	if t := s.lastMetaAt.Load(); t != nil {
293: 		at = t
294: 	}
295: 	j, _ := json.Marshal(resp{Current: cur, UpdatedAt: at, SourceOK: s.sourceOK.Load()})
296: 	w.Header().Set("Content-Type", "application/json")
297: 	w.Write(j)
298: }
299: 
300: func (s *Station) addClient(c *Client) {
301: 	s.muClients.Lock()
302: 	if s.clients == nil {
303: 		s.clients = map[*Client]struct{}{}
304: 	}
305: 	s.clients[c] = struct{}{}
306: 	s.muClients.Unlock()
307: 	log.Printf("[%s] client +1 (now %d)", s.ID, s.clientCount())
308: }
309: 
310: func (s *Station) removeClient(c *Client) {
311: 	c.closed.Store(true)
312: 	s.muClients.Lock()
313: 	delete(s.clients, c)
314: 	s.muClients.Unlock()
315: 	log.Printf("[%s] client -1 (now %d)", s.ID, s.clientCount())
316: }
317: 
318: func (s *Station) clientCount() int {
319: 	s.muClients.Lock()
320: 	defer s.muClients.Unlock()
321: 	return len(s.clients)
322: }
323: 
324: // ---- Client write with ICY injection ----
325: 
326: func (c *Client) writeWithICY(chunk []byte) error {
327: 	for len(chunk) > 0 {
328: 		if c.bytesToMet > len(chunk) {
329: 			// Write all and decrement.
330: 			if _, err := c.w.Write(chunk); err != nil {
331: 				return err
332: 			}
333: 			c.bytesToMet -= len(chunk)
334: 			c.flusher.Flush()
335: 			return nil
336: 		}
337: 		// Write up to boundary.
338: 		n := c.bytesToMet
339: 		if n > 0 {
340: 			if _, err := c.w.Write(chunk[:n]); err != nil {
341: 				return err
342: 			}
343: 			c.flusher.Flush()
344: 			chunk = chunk[n:]
345: 		}
346: 		// Inject metadata block.
347: 		meta := ""
348: 		if p := c.station.curMeta.Load(); p != nil {
349: 			meta = *p
350: 		}
351: 		block := buildICYBlock(meta)
352: 		if _, err := c.w.Write(block); err != nil {
353: 			return err
354: 		}
355: 		c.flusher.Flush()
356: 		c.bytesToMet = c.station.MetaInt
357: 	}
358: 	return nil
359: }
360: 
361: // ---- ICY helpers ----
362: 
363: func buildICYBlock(text string) []byte {
364: 	if text == "" {
365: 		return []byte{0x00}
366: 	}
367: 	// ICY wants 16-byte padded, length byte is count of 16-byte chunks (max 255).
368: 	payload := []byte(text)
369: 	if len(payload) > 255*16 {
370: 		payload = payload[:255*16]
371: 	}
372: 	blocks := (len(payload) + 15) / 16
373: 	if blocks > 255 {
374: 		blocks = 255
375: 	}
376: 	pad := blocks*16 - len(payload)
377: 	var b bytes.Buffer
378: 	b.WriteByte(byte(blocks))
379: 	b.Write(payload)
380: 	if pad > 0 {
381: 		b.Write(bytes.Repeat([]byte{0x00}, pad))
382: 	}
383: 	return b.Bytes()
384: }
385: 
386: func parseTitle(body []byte) string {
387: 	trim := strings.TrimSpace(string(body))
388: 	if strings.HasPrefix(trim, "{") {
389: 		var m map[string]any
390: 		if json.Unmarshal(body, &m) == nil {
391: 			// try common shapes
392: 			if t, ok := m["title"].(string); ok && t != "" {
393: 				return t
394: 			}
395: 			if track, ok := m["track"].(map[string]any); ok {
396: 				a, _ := track["artist"].(string)
397: 				t, _ := track["title"].(string)
398: 				return strings.TrimSpace(strings.TrimSpace(a) + " - " + strings.TrimSpace(t))
399: 			}
400: 			// fallback: flatten
401: 			j, _ := json.Marshal(m)
402: 			return string(j)
403: 		}
404: 	}
405: 	return trim
406: }
407: 
408: func normalizeTitle(s string) string {
409: 	s = strings.ReplaceAll(s, "\n", " ")
410: 	s = strings.Join(strings.Fields(s), " ")
411: 	return s
412: }
413: 
414: func sanitizeQuotes(s string) string {
415: 	return strings.ReplaceAll(s, "'", "") // minimal; extend if you need ISO-8859-1 mapping
416: }
417: 
418: // ---- main / routing ----
419: 
420: func main() {
421: 	// Define your stations here (swap URLs for real ones)
422: 	stations := []*Station{
423: 		newStation("fip", "FIP (proxy)", defaultMetaInt, 128,
424: 			"https://example.com/fip.mp3",
425: 			"https://fip-metadata.fly.dev/"),
426: 		newStation("fip_hiphop", "FIP Hip-Hop (proxy)", defaultMetaInt, 128,
427: 			"https://example.com/fip_hiphop.mp3",
428: 			"https://fip-metadata.fly.dev/hiphop"),
429: 	}
430: 
431: 	mux := http.NewServeMux()
432: 	mux.HandleFunc("/stations", func(w http.ResponseWriter, _ *http.Request) {
433: 		type s struct {
434: 			ID           string `json:"id"`
435: 			Clients      int    `json:"clients"`
436: 			SourceOK     bool   `json:"sourceConnected"`
437: 			Stream       string `json:"stream"`
438: 			MetaEndpoint string `json:"meta"`
439: 		}
440: 		var out []s
441: 		for _, st := range stations {
442: 			out = append(out, s{
443: 				ID:           st.ID,
444: 				Clients:      st.clientCount(),
445: 				SourceOK:     st.sourceOK.Load(),
446: 				Stream:       fmt.Sprintf("/%s/stream", st.ID),
447: 				MetaEndpoint: fmt.Sprintf("/%s/meta", st.ID),
448: 			})
449: 		}
450: 		j, _ := json.Marshal(out)
451: 		w.Header().Set("Content-Type", "application/json")
452: 		w.Write(j)
453: 	})
454: 	mux.HandleFunc("/healthz", func(w http.ResponseWriter, _ *http.Request) {
455: 		type h struct{ OK bool `json:"ok"` }
456: 		w.Header().Set("Content-Type", "application/json")
457: 		w.WriteHeader(200)
458: 		_ = json.NewEncoder(w).Encode(h{OK: true})
459: 	})
460: 	// Per-station routes
461: 	for _, st := range stations {
462: 		s := st
463: 		mux.HandleFunc("/"+s.ID+"/stream", func(w http.ResponseWriter, r *http.Request) {
464: 			// ensure writer is not proxied through buffering reverse proxies if you expose it
465: 			w.Header().Set("Cache-Control", "no-store")
466: 			w.Header().Set("Connection", "close")
467: 			s.handleStream(w, r)
468: 		})
469: 		mux.HandleFunc("/"+s.ID+"/meta", s.handleMeta)
470: 	}
471: 
472: 	// Start stations
473: 	ctx, cancel := context.WithCancel(context.Background())
474: 	defer cancel()
475: 	var wg sync.WaitGroup
476: 	for _, s := range stations {
477: 		s.Start(ctx, &wg)
478: 	}
479: 
480: 	// HTTP server with sane timeouts; disable read timeout for streaming if needed.
481: 	srv := &http.Server{
482: 		Addr:         listenAddr,
483: 		Handler:      mux,
484: 		ReadTimeout:  15 * time.Second,
485: 		WriteTimeout: 0, // streaming
486: 		IdleTimeout:  0, // streaming
487: 		BaseContext: func(_ net.Listener) context.Context { return ctx },
488: 	}
489: 	log.Printf("listening on http://%s  (try /stations)", listenAddr)
490: 	if err := srv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
491: 		log.Fatal(err)
492: 	}
493: 	wg.Wait()
494: }
495: 
496: func newStation(id, name string, metaint, br int, srcURL, metaURL string) *Station {
497: 	tr := &http.Transport{
498: 		Proxy:               http.ProxyFromEnvironment,
499: 		MaxIdleConns:        100,
500: 		IdleConnTimeout:     30 * time.Second,
501: 		DisableCompression:  true,
502: 		ExpectContinueTimeout: 1 * time.Second,
503: 	}
504: 	return &Station{
505: 		ID:          id,
506: 		ICYName:     name,
507: 		MetaInt:     metaint,
508: 		BitrateHint: br,
509: 		SourceURL:   srcURL,
510: 		MetadataURL: metaURL,
511: 		srcClient:   &http.Client{Transport: tr, Timeout: 0},           // streaming: no total timeout
512: 		metaClient:  &http.Client{Transport: tr, Timeout: 10 * time.Second},
513: 		ring:        NewRing(ringBytes),
514: 		chunkBus:    make(chan []byte, 32), // small buffer; drops on pressure
515: 	}
516: }
517: 
518: // ---- helpers ----
519: 
520: func statusCode(r *http.Response) int {
521: 	if r == nil {
522: 		return 0
523: 	}
524: 	return r.StatusCode
525: }
526: func min(a, b int) int { if a < b { return a }; return b }
527: func minDur(a, b time.Duration) time.Duration { if a < b { return a }; return b }
528: ```
529: 
530: How it works (brief):
531: 
532: * One goroutine reads each upstream MP3 and feeds a small ring + a chunk channel.
533: * Another polls metadata and updates an atomic string like `StreamTitle='Artist - Title';`.
534: * Each client connection counts bytes until `metaInt`, then injects a correctly padded ICY block.
535: * Routes are path-based: `/fip/stream`, `/fip/meta`, `/fip_hiphop/…`.
536: * It’s all stdlib; no deps, no CGO, single binary.
537: 
538: Alt path (Node): if you want a super-fast hack and don’t care about single-binary deploys, the Node version you saw earlier is fine; just mind long-lived connections and per-client backpressure.
539: 
540: Next logical extension: YAML config + systemd unit + optional basic auth + Prometheus metrics.
</file>

<file path="internal/application/config/config_test.go">
 1: // ABOUTME: Tests for YAML configuration parsing
 2: // ABOUTME: Verifies config structure and validation
 3: package config
 4: import (
 5: 	"os"
 6: 	"path/filepath"
 7: 	"testing"
 8: )
 9: func TestLoad(t *testing.T) {
10: 	yamlContent := `
11: listen:
12:   host: 0.0.0.0
13:   port: 8000
14: stations:
15:   - id: test_station
16:     icy:
17:       name: "Test Station"
18:       metaint: 16384
19:       bitrate_hint_kbps: 128
20:     source:
21:       url: "http://example.com/stream.mp3"
22:       connect_timeout_ms: 5000
23:       read_timeout_ms: 15000
24:     metadata:
25:       url: "http://example.com/meta"
26:       poll_ms: 3000
27:       build:
28:         format: "StreamTitle='{artist} - {title}';"
29:     buffering:
30:       ring_bytes: 262144
31: `
32: 	tmpDir := t.TempDir()
33: 	cfgPath := filepath.Join(tmpDir, "config.yaml")
34: 	if err := os.WriteFile(cfgPath, []byte(yamlContent), 0644); err != nil {
35: 		t.Fatalf("write config: %v", err)
36: 	}
37: 	cfg, err := Load(cfgPath)
38: 	if err != nil {
39: 		t.Fatalf("Load failed: %v", err)
40: 	}
41: 	if cfg.Listen.Host != "0.0.0.0" {
42: 		t.Errorf("expected host 0.0.0.0, got %s", cfg.Listen.Host)
43: 	}
44: 	if cfg.Listen.Port != 8000 {
45: 		t.Errorf("expected port 8000, got %d", cfg.Listen.Port)
46: 	}
47: 	if len(cfg.Stations) != 1 {
48: 		t.Fatalf("expected 1 station, got %d", len(cfg.Stations))
49: 	}
50: 	st := cfg.Stations[0]
51: 	if st.ID != "test_station" {
52: 		t.Errorf("expected ID test_station, got %s", st.ID)
53: 	}
54: }
</file>

<file path="internal/application/config/config.go">
 1: // ABOUTME: YAML configuration parsing and validation
 2: // ABOUTME: Defines structure for multi-station proxy configuration
 3: package config
 4: import (
 5: 	"fmt"
 6: 	"os"
 7: 	"gopkg.in/yaml.v3"
 8: )
 9: type Config struct {
10: 	Listen   ListenConfig    `yaml:"listen"`
11: 	Stations []StationConfig `yaml:"stations"`
12: 	Logging  LoggingConfig   `yaml:"logging"`
13: }
14: type ListenConfig struct {
15: 	Host string `yaml:"host"`
16: 	Port int    `yaml:"port"`
17: }
18: type StationConfig struct {
19: 	ID        string          `yaml:"id"`
20: 	ICY       ICYConfig       `yaml:"icy"`
21: 	Source    SourceConfig    `yaml:"source"`
22: 	Metadata  MetadataConfig  `yaml:"metadata"`
23: 	Buffering BufferingConfig `yaml:"buffering"`
24: }
25: type ICYConfig struct {
26: 	Name            string `yaml:"name"`
27: 	MetaInt         int    `yaml:"metaint"`
28: 	BitrateHintKbps int    `yaml:"bitrate_hint_kbps"`
29: }
30: type SourceConfig struct {
31: 	URL              string            `yaml:"url"`
32: 	RequestHeaders   map[string]string `yaml:"request_headers"`
33: 	ConnectTimeoutMs int               `yaml:"connect_timeout_ms"`
34: 	ReadTimeoutMs    int               `yaml:"read_timeout_ms"`
35: }
36: type MetadataConfig struct {
37: 	URL    string      `yaml:"url"`
38: 	PollMs int         `yaml:"poll_ms"`
39: 	Build  BuildConfig `yaml:"build"`
40: }
41: type BuildConfig struct {
42: 	Format              string   `yaml:"format"`
43: 	StripSingleQuotes   bool     `yaml:"strip_single_quotes"`
44: 	Encoding            string   `yaml:"encoding"`
45: 	NormalizeWhitespace bool     `yaml:"normalize_whitespace"`
46: 	FallbackKeyOrder    []string `yaml:"fallback_key_order"`
47: }
48: type BufferingConfig struct {
49: 	RingBytes             int `yaml:"ring_bytes"`
50: 	ClientPendingMaxBytes int `yaml:"client_pending_max_bytes"`
51: }
52: type LoggingConfig struct {
53: 	Level string `yaml:"level"`
54: 	JSON  bool   `yaml:"json"`
55: }
56: func Load(path string) (*Config, error) {
57: 	data, err := os.ReadFile(path)
58: 	if err != nil {
59: 		return nil, fmt.Errorf("read config: %w", err)
60: 	}
61: 	var cfg Config
62: 	if err := yaml.Unmarshal(data, &cfg); err != nil {
63: 		return nil, fmt.Errorf("parse yaml: %w", err)
64: 	}
65: 	return &cfg, nil
66: }
</file>

<file path="internal/application/manager/manager_test.go">
 1: // ABOUTME: Tests for station manager lifecycle
 2: // ABOUTME: Verifies station creation and lookup
 3: package manager
 4: import (
 5: 	"testing"
 6: 	"github.com/harper/radio-metadata-proxy/internal/application/config"
 7: )
 8: func TestManager_NewFromConfig(t *testing.T) {
 9: 	cfg := &config.Config{
10: 		Stations: []config.StationConfig{
11: 			{
12: 				ID: "test1",
13: 				ICY: config.ICYConfig{
14: 					Name:            "Test 1",
15: 					MetaInt:         16384,
16: 					BitrateHintKbps: 128,
17: 				},
18: 				Source: config.SourceConfig{
19: 					URL:              "http://example.com/test1.mp3",
20: 					ConnectTimeoutMs: 5000,
21: 				},
22: 				Metadata: config.MetadataConfig{
23: 					URL:    "http://example.com/meta1",
24: 					PollMs: 3000,
25: 				},
26: 				Buffering: config.BufferingConfig{
27: 					RingBytes: 262144,
28: 				},
29: 			},
30: 		},
31: 	}
32: 	mgr, err := NewFromConfig(cfg)
33: 	if err != nil {
34: 		t.Fatalf("NewFromConfig failed: %v", err)
35: 	}
36: 	if len(mgr.List()) != 1 {
37: 		t.Errorf("expected 1 station, got %d", len(mgr.List()))
38: 	}
39: 	st := mgr.Get("test1")
40: 	if st == nil {
41: 		t.Fatal("expected to find test1 station")
42: 	}
43: 	if st.ID() != "test1" {
44: 		t.Errorf("expected ID test1, got %s", st.ID())
45: 	}
46: }
</file>

<file path="internal/domain/interfaces.go">
 1: // ABOUTME: Domain interfaces for dependency inversion
 2: // ABOUTME: Allows station to depend on abstractions, not concrete implementations
 3: package domain
 4: import (
 5: 	"context"
 6: 	"io"
 7: )
 8: // StreamSource provides MP3 audio stream bytes
 9: type StreamSource interface {
10: 	Connect(ctx context.Context) (io.ReadCloser, error)
11: }
12: // MetadataProvider fetches current track metadata
13: type MetadataProvider interface {
14: 	Fetch(ctx context.Context) (string, error)
15: }
</file>

<file path="internal/infrastructure/http/handlers_test.go">
  1: // ABOUTME: Tests for HTTP handlers
  2: // ABOUTME: Verifies routing, headers, and response formats
  3: package http
  4: import (
  5: 	"encoding/json"
  6: 	"net/http"
  7: 	"net/http/httptest"
  8: 	"testing"
  9: 	"github.com/harper/radio-metadata-proxy/internal/application/manager"
 10: 	"github.com/harper/radio-metadata-proxy/internal/application/config"
 11: )
 12: func TestStreamHandler_404(t *testing.T) {
 13: 	cfg := &config.Config{
 14: 		Stations: []config.StationConfig{},
 15: 	}
 16: 	mgr, _ := manager.NewFromConfig(cfg)
 17: 	handler := NewStreamHandler(mgr)
 18: 	req := httptest.NewRequest("GET", "/nonexistent/stream", nil)
 19: 	rec := httptest.NewRecorder()
 20: 	handler.ServeHTTP(rec, req)
 21: 	if rec.Code != http.StatusNotFound {
 22: 		t.Errorf("expected 404, got %d", rec.Code)
 23: 	}
 24: }
 25: func TestStreamHandler_Success(t *testing.T) {
 26: 	cfg := &config.Config{
 27: 		Stations: []config.StationConfig{
 28: 			{
 29: 				ID: "test_station",
 30: 				ICY: config.ICYConfig{
 31: 					Name:            "Test Station",
 32: 					MetaInt:         16384,
 33: 					BitrateHintKbps: 128,
 34: 				},
 35: 				Source: config.SourceConfig{
 36: 					URL:              "http://example.com/stream.mp3",
 37: 					ConnectTimeoutMs: 5000,
 38: 				},
 39: 				Metadata: config.MetadataConfig{
 40: 					URL:    "http://example.com/meta",
 41: 					PollMs: 3000,
 42: 				},
 43: 				Buffering: config.BufferingConfig{
 44: 					RingBytes: 262144,
 45: 				},
 46: 			},
 47: 		},
 48: 	}
 49: 	mgr, _ := manager.NewFromConfig(cfg)
 50: 	handler := NewStreamHandler(mgr)
 51: 	req := httptest.NewRequest("GET", "/test_station/stream", nil)
 52: 	rec := httptest.NewRecorder()
 53: 	handler.ServeHTTP(rec, req)
 54: 	if rec.Code != http.StatusOK {
 55: 		t.Errorf("expected 200, got %d", rec.Code)
 56: 	}
 57: 	if ct := rec.Header().Get("Content-Type"); ct != "audio/mpeg" {
 58: 		t.Errorf("expected Content-Type audio/mpeg, got %s", ct)
 59: 	}
 60: 	if name := rec.Header().Get("icy-name"); name != "Test Station" {
 61: 		t.Errorf("expected icy-name 'Test Station', got %s", name)
 62: 	}
 63: 	if metaint := rec.Header().Get("icy-metaint"); metaint != "16384" {
 64: 		t.Errorf("expected icy-metaint 16384, got %s", metaint)
 65: 	}
 66: 	if br := rec.Header().Get("icy-br"); br != "128" {
 67: 		t.Errorf("expected icy-br 128, got %s", br)
 68: 	}
 69: }
 70: func TestMetaHandler_404(t *testing.T) {
 71: 	cfg := &config.Config{
 72: 		Stations: []config.StationConfig{},
 73: 	}
 74: 	mgr, _ := manager.NewFromConfig(cfg)
 75: 	handler := NewMetaHandler(mgr)
 76: 	req := httptest.NewRequest("GET", "/nonexistent/meta", nil)
 77: 	rec := httptest.NewRecorder()
 78: 	handler.ServeHTTP(rec, req)
 79: 	if rec.Code != http.StatusNotFound {
 80: 		t.Errorf("expected 404, got %d", rec.Code)
 81: 	}
 82: }
 83: func TestMetaHandler_Success(t *testing.T) {
 84: 	cfg := &config.Config{
 85: 		Stations: []config.StationConfig{
 86: 			{
 87: 				ID: "test_station",
 88: 				ICY: config.ICYConfig{
 89: 					Name:            "Test Station",
 90: 					MetaInt:         16384,
 91: 					BitrateHintKbps: 128,
 92: 				},
 93: 				Source: config.SourceConfig{
 94: 					URL:              "http://example.com/stream.mp3",
 95: 					ConnectTimeoutMs: 5000,
 96: 				},
 97: 				Metadata: config.MetadataConfig{
 98: 					URL:    "http://example.com/meta",
 99: 					PollMs: 3000,
100: 				},
101: 				Buffering: config.BufferingConfig{
102: 					RingBytes: 262144,
103: 				},
104: 			},
105: 		},
106: 	}
107: 	mgr, _ := manager.NewFromConfig(cfg)
108: 	handler := NewMetaHandler(mgr)
109: 	req := httptest.NewRequest("GET", "/test_station/meta", nil)
110: 	rec := httptest.NewRecorder()
111: 	handler.ServeHTTP(rec, req)
112: 	if rec.Code != http.StatusOK {
113: 		t.Errorf("expected 200, got %d", rec.Code)
114: 	}
115: 	if ct := rec.Header().Get("Content-Type"); ct != "application/json" {
116: 		t.Errorf("expected Content-Type application/json, got %s", ct)
117: 	}
118: 	var resp struct {
119: 		Current       string  `json:"current"`
120: 		UpdatedAt     *string `json:"updated_at,omitempty"`
121: 		SourceHealthy bool    `json:"sourceHealthy"`
122: 	}
123: 	if err := json.NewDecoder(rec.Body).Decode(&resp); err != nil {
124: 		t.Fatalf("failed to decode response: %v", err)
125: 	}
126: 	if resp.Current != "" {
127: 		t.Errorf("expected empty current metadata, got %s", resp.Current)
128: 	}
129: 	if resp.SourceHealthy {
130: 		t.Error("expected sourceHealthy false initially")
131: 	}
132: }
133: func TestStationsHandler(t *testing.T) {
134: 	cfg := &config.Config{
135: 		Stations: []config.StationConfig{
136: 			{
137: 				ID: "station1",
138: 				ICY: config.ICYConfig{
139: 					Name:            "Station 1",
140: 					MetaInt:         16384,
141: 					BitrateHintKbps: 128,
142: 				},
143: 				Source: config.SourceConfig{
144: 					URL:              "http://example.com/stream1.mp3",
145: 					ConnectTimeoutMs: 5000,
146: 				},
147: 				Metadata: config.MetadataConfig{
148: 					URL:    "http://example.com/meta1",
149: 					PollMs: 3000,
150: 				},
151: 				Buffering: config.BufferingConfig{
152: 					RingBytes: 262144,
153: 				},
154: 			},
155: 			{
156: 				ID: "station2",
157: 				ICY: config.ICYConfig{
158: 					Name:            "Station 2",
159: 					MetaInt:         16384,
160: 					BitrateHintKbps: 128,
161: 				},
162: 				Source: config.SourceConfig{
163: 					URL:              "http://example.com/stream2.mp3",
164: 					ConnectTimeoutMs: 5000,
165: 				},
166: 				Metadata: config.MetadataConfig{
167: 					URL:    "http://example.com/meta2",
168: 					PollMs: 3000,
169: 				},
170: 				Buffering: config.BufferingConfig{
171: 					RingBytes: 262144,
172: 				},
173: 			},
174: 		},
175: 	}
176: 	mgr, _ := manager.NewFromConfig(cfg)
177: 	handler := NewStationsHandler(mgr)
178: 	req := httptest.NewRequest("GET", "/stations", nil)
179: 	rec := httptest.NewRecorder()
180: 	handler.ServeHTTP(rec, req)
181: 	if rec.Code != http.StatusOK {
182: 		t.Errorf("expected 200, got %d", rec.Code)
183: 	}
184: 	if ct := rec.Header().Get("Content-Type"); ct != "application/json" {
185: 		t.Errorf("expected Content-Type application/json, got %s", ct)
186: 	}
187: 	var stations []struct {
188: 		ID            string `json:"id"`
189: 		StreamURL     string `json:"stream_url"`
190: 		MetaURL       string `json:"meta_url"`
191: 		Clients       int    `json:"clients"`
192: 		SourceHealthy bool   `json:"sourceHealthy"`
193: 	}
194: 	if err := json.NewDecoder(rec.Body).Decode(&stations); err != nil {
195: 		t.Fatalf("failed to decode response: %v", err)
196: 	}
197: 	if len(stations) != 2 {
198: 		t.Errorf("expected 2 stations, got %d", len(stations))
199: 	}
200: }
201: func TestHealthzHandler(t *testing.T) {
202: 	req := httptest.NewRequest("GET", "/healthz", nil)
203: 	rec := httptest.NewRecorder()
204: 	HealthzHandler(rec, req)
205: 	if rec.Code != http.StatusOK {
206: 		t.Errorf("expected 200, got %d", rec.Code)
207: 	}
208: 	if ct := rec.Header().Get("Content-Type"); ct != "application/json" {
209: 		t.Errorf("expected Content-Type application/json, got %s", ct)
210: 	}
211: 	var resp struct {
212: 		OK bool `json:"ok"`
213: 	}
214: 	if err := json.NewDecoder(rec.Body).Decode(&resp); err != nil {
215: 		t.Fatalf("failed to decode response: %v", err)
216: 	}
217: 	if !resp.OK {
218: 		t.Error("expected ok: true")
219: 	}
220: }
</file>

<file path="internal/infrastructure/icy/encoder_test.go">
 1: // ABOUTME: Tests for ICY metadata block encoding
 2: // ABOUTME: Verifies padding, length byte calculation, and truncation
 3: package icy
 4: import (
 5: 	"testing"
 6: )
 7: func TestBuildBlock_Empty(t *testing.T) {
 8: 	result := BuildBlock("")
 9: 	if len(result) != 1 || result[0] != 0x00 {
10: 		t.Errorf("empty string should produce single zero byte, got %v", result)
11: 	}
12: }
13: func TestBuildBlock_ShortString(t *testing.T) {
14: 	result := BuildBlock("StreamTitle='Test';")
15: 	// Should be: length byte + 19 chars + 13 padding = 33 bytes
16: 	if len(result) != 33 {
17: 		t.Errorf("expected 33 bytes, got %d", len(result))
18: 	}
19: 	// Length byte should be 2 (2 * 16 = 32 bytes of data+padding)
20: 	if result[0] != 2 {
21: 		t.Errorf("expected length byte 2, got %d", result[0])
22: 	}
23: 	// Verify content
24: 	content := string(result[1:20])
25: 	if content != "StreamTitle='Test';" {
26: 		t.Errorf("expected 'StreamTitle='Test';', got %q", content)
27: 	}
28: 	// Verify padding is zeros
29: 	for i := 20; i < 33; i++ {
30: 		if result[i] != 0x00 {
31: 			t.Errorf("byte %d should be 0x00, got 0x%02x", i, result[i])
32: 		}
33: 	}
34: }
35: func TestBuildBlock_Truncation(t *testing.T) {
36: 	// Create string larger than max (255 * 16 = 4080 bytes)
37: 	longStr := string(make([]byte, 5000))
38: 	result := BuildBlock(longStr)
39: 	// Length byte should be 255
40: 	if result[0] != 255 {
41: 		t.Errorf("expected length byte 255, got %d", result[0])
42: 	}
43: 	// Total length should be 1 + 255*16 = 4081 bytes
44: 	expected := 1 + 255*16
45: 	if len(result) != expected {
46: 		t.Errorf("expected %d bytes, got %d", expected, len(result))
47: 	}
48: }
</file>

<file path="internal/infrastructure/icy/encoder.go">
 1: // ABOUTME: ICY metadata block encoding for Shoutcast/Icecast protocol
 2: // ABOUTME: Handles 16-byte padding and length byte calculation per ICY spec
 3: package icy
 4: import "bytes"
 5: // BuildBlock encodes text as ICY metadata block with 16-byte padding.
 6: // Returns length byte (count of 16-byte chunks) followed by padded payload.
 7: // Max size: 255 * 16 = 4080 bytes.
 8: func BuildBlock(text string) []byte {
 9: 	if text == "" {
10: 		return []byte{0x00}
11: 	}
12: 	payload := []byte(text)
13: 	// Truncate if exceeds max (255 blocks * 16 bytes)
14: 	if len(payload) > 255*16 {
15: 		payload = payload[:255*16]
16: 	}
17: 	// Calculate blocks (round up)
18: 	blocks := (len(payload) + 15) / 16
19: 	if blocks > 255 {
20: 		blocks = 255
21: 	}
22: 	// Calculate padding
23: 	pad := blocks*16 - len(payload)
24: 	// Build result: length byte + payload + padding
25: 	var buf bytes.Buffer
26: 	buf.WriteByte(byte(blocks))
27: 	buf.Write(payload)
28: 	if pad > 0 {
29: 		buf.Write(bytes.Repeat([]byte{0x00}, pad))
30: 	}
31: 	return buf.Bytes()
32: }
</file>

<file path="internal/infrastructure/ring/buffer_test.go">
 1: // ABOUTME: Tests for circular ring buffer implementation
 2: // ABOUTME: Verifies write, wrap-around, overflow, and snapshot operations
 3: package ring
 4: import (
 5: 	"testing"
 6: )
 7: func TestNew(t *testing.T) {
 8: 	buf := New(1024)
 9: 	if buf == nil {
10: 		t.Fatal("New should return non-nil buffer")
11: 	}
12: 	snap := buf.Snapshot()
13: 	if len(snap) != 0 {
14: 		t.Errorf("new buffer should be empty, got %d bytes", len(snap))
15: 	}
16: }
17: func TestWrite_Simple(t *testing.T) {
18: 	buf := New(1024)
19: 	data := []byte("hello")
20: 	buf.Write(data)
21: 	snap := buf.Snapshot()
22: 	if string(snap) != "hello" {
23: 		t.Errorf("expected 'hello', got %q", snap)
24: 	}
25: }
26: func TestWrite_Overflow(t *testing.T) {
27: 	buf := New(100)
28: 	// Write 150 bytes - should trigger overflow
29: 	data := make([]byte, 150)
30: 	for i := range data {
31: 		data[i] = byte(i)
32: 	}
33: 	buf.Write(data)
34: 	snap := buf.Snapshot()
35: 	// Should have dropped oldest 25 bytes, kept newest 100
36: 	if len(snap) != 100 {
37: 		t.Errorf("expected 100 bytes, got %d", len(snap))
38: 	}
39: 	// Should contain bytes 50-149 (dropped 0-49)
40: 	for i, v := range snap {
41: 		expected := byte(50 + i)
42: 		if v != expected {
43: 			t.Errorf("byte %d: expected %d, got %d", i, expected, v)
44: 			break
45: 		}
46: 	}
47: }
</file>

<file path="internal/infrastructure/ring/buffer.go">
 1: // ABOUTME: Circular ring buffer for audio stream smoothing
 2: // ABOUTME: Drops oldest data on overflow to maintain fixed size
 3: package ring
 4: import "sync"
 5: type Buffer struct {
 6: 	buf []byte
 7: 	w   int  // write position
 8: 	n   int  // bytes stored
 9: 	mu  sync.Mutex
10: }
11: func New(size int) *Buffer {
12: 	return &Buffer{buf: make([]byte, size)}
13: }
14: func (b *Buffer) Write(p []byte) {
15: 	b.mu.Lock()
16: 	defer b.mu.Unlock()
17: 	for len(p) > 0 {
18: 		space := len(b.buf) - b.n
19: 		if space == 0 {
20: 			// Drop oldest 25%
21: 			drop := len(b.buf) / 4
22: 			b.w = (b.w + drop) % len(b.buf)
23: 			b.n -= drop
24: 			if b.n < 0 {
25: 				b.n = 0
26: 			}
27: 			space = len(b.buf) - b.n
28: 		}
29: 		chunk := len(p)
30: 		if chunk > space {
31: 			chunk = space
32: 		}
33: 		end := (b.w + b.n) % len(b.buf)
34: 		right := len(b.buf) - end
35: 		if right > chunk {
36: 			right = chunk
37: 		}
38: 		copy(b.buf[end:end+right], p[:right])
39: 		if right < chunk {
40: 			copy(b.buf[0:chunk-right], p[right:chunk])
41: 		}
42: 		b.n += chunk
43: 		p = p[chunk:]
44: 	}
45: }
46: func (b *Buffer) Snapshot() []byte {
47: 	b.mu.Lock()
48: 	defer b.mu.Unlock()
49: 	out := make([]byte, b.n)
50: 	if b.n == 0 {
51: 		return out
52: 	}
53: 	head := b.w
54: 	tail := (b.w + b.n) % len(b.buf)
55: 	if head < tail {
56: 		copy(out, b.buf[head:tail])
57: 	} else {
58: 		copy(out, b.buf[head:])
59: 		copy(out[len(b.buf)-head:], b.buf[:tail])
60: 	}
61: 	return out
62: }
</file>

<file path="internal/infrastructure/source/http_test.go">
 1: // ABOUTME: Tests for HTTP stream source implementation
 2: // ABOUTME: Verifies connection handling and error cases
 3: package source
 4: import (
 5: 	"context"
 6: 	"net/http"
 7: 	"net/http/httptest"
 8: 	"testing"
 9: 	"time"
10: )
11: func TestHTTPSource_Connect(t *testing.T) {
12: 	// Create test server
13: 	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
14: 		// Check headers
15: 		if r.Header.Get("Icy-MetaData") != "0" {
16: 			t.Errorf("expected Icy-MetaData: 0 header")
17: 		}
18: 		w.Header().Set("Content-Type", "audio/mpeg")
19: 		w.WriteHeader(http.StatusOK)
20: 		w.Write([]byte("audio data"))
21: 	}))
22: 	defer server.Close()
23: 	cfg := HTTPConfig{
24: 		URL:            server.URL,
25: 		ConnectTimeout: 5 * time.Second,
26: 		ReadTimeout:    10 * time.Second,
27: 	}
28: 	src := NewHTTP(cfg)
29: 	ctx := context.Background()
30: 	reader, err := src.Connect(ctx)
31: 	if err != nil {
32: 		t.Fatalf("Connect failed: %v", err)
33: 	}
34: 	defer reader.Close()
35: 	buf := make([]byte, 10)
36: 	n, _ := reader.Read(buf)
37: 	if string(buf[:n]) != "audio data" {
38: 		t.Errorf("expected 'audio data', got %q", buf[:n])
39: 	}
40: }
</file>

<file path="internal/infrastructure/source/http.go">
 1: // ABOUTME: HTTP stream source implementation for MP3 audio
 2: // ABOUTME: Handles upstream connection with timeouts and proper headers
 3: package source
 4: import (
 5: 	"context"
 6: 	"fmt"
 7: 	"io"
 8: 	"net/http"
 9: 	"time"
10: )
11: type HTTPConfig struct {
12: 	URL            string
13: 	ConnectTimeout time.Duration
14: 	ReadTimeout    time.Duration
15: 	Headers        map[string]string
16: }
17: type HTTPSource struct {
18: 	cfg    HTTPConfig
19: 	client *http.Client
20: }
21: func NewHTTP(cfg HTTPConfig) *HTTPSource {
22: 	transport := &http.Transport{
23: 		DisableCompression:    true,
24: 		ExpectContinueTimeout: 1 * time.Second,
25: 	}
26: 	client := &http.Client{
27: 		Transport: transport,
28: 		Timeout:   0, // No total timeout for streaming
29: 	}
30: 	return &HTTPSource{
31: 		cfg:    cfg,
32: 		client: client,
33: 	}
34: }
35: func (h *HTTPSource) Connect(ctx context.Context) (io.ReadCloser, error) {
36: 	req, err := http.NewRequestWithContext(ctx, "GET", h.cfg.URL, nil)
37: 	if err != nil {
38: 		return nil, fmt.Errorf("create request: %w", err)
39: 	}
40: 	// Set ICY headers
41: 	req.Header.Set("Icy-MetaData", "0")
42: 	// Set custom headers
43: 	for k, v := range h.cfg.Headers {
44: 		req.Header.Set(k, v)
45: 	}
46: 	resp, err := h.client.Do(req)
47: 	if err != nil {
48: 		return nil, fmt.Errorf("http request: %w", err)
49: 	}
50: 	if resp.StatusCode != http.StatusOK {
51: 		resp.Body.Close()
52: 		return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
53: 	}
54: 	return resp.Body, nil
55: }
</file>

<file path=".dockerignore">
1: .git
2: .gitignore
3: README.md
4: docs/
5: *.md
6: .vscode
7: .idea
</file>

<file path="docker-compose.yaml">
 1: services:
 2:   icyproxy:
 3:     build:
 4:       context: .
 5:       dockerfile: Dockerfile
 6:     container_name: radio-metadata-proxy
 7:     ports:
 8:       - "8000:8000"
 9:     volumes:
10:       - ./config.yaml:/etc/icyproxy/config.yaml:ro
11:     restart: unless-stopped
12:     environment:
13:       - TZ=America/Chicago
14:     healthcheck:
15:       test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8000/healthz"]
16:       interval: 30s
17:       timeout: 10s
18:       retries: 3
19:       start_period: 10s
</file>

<file path="Dockerfile">
 1: # Build stage
 2: FROM golang:1.23-alpine AS builder
 3: 
 4: WORKDIR /app
 5: 
 6: # Copy go mod files
 7: COPY go.mod go.sum ./
 8: RUN go mod download
 9: 
10: # Copy source
11: COPY . .
12: 
13: # Build binary
14: RUN CGO_ENABLED=0 GOOS=linux go build -o icyproxy ./cmd/icyproxy
15: 
16: # Runtime stage
17: FROM alpine:latest
18: 
19: RUN apk --no-cache add ca-certificates
20: 
21: WORKDIR /app
22: 
23: COPY --from=builder /app/icyproxy .
24: COPY configs/example.yaml /etc/icyproxy/config.yaml
25: 
26: EXPOSE 8000
27: 
28: CMD ["./icyproxy", "/etc/icyproxy/config.yaml"]
</file>

<file path="cmd/icyproxy/main.go">
 1: // ABOUTME: Main entry point for ICY metadata proxy
 2: // ABOUTME: Loads config, starts stations, runs HTTP server
 3: package main
 4: import (
 5: 	"context"
 6: 	"fmt"
 7: 	"log"
 8: 	"net"
 9: 	nethttp "net/http"
10: 	"os"
11: 	"os/signal"
12: 	"syscall"
13: 	"time"
14: 	"github.com/harper/radio-metadata-proxy/internal/application/config"
15: 	"github.com/harper/radio-metadata-proxy/internal/application/manager"
16: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/http"
17: )
18: func main() {
19: 	if err := run(); err != nil {
20: 		log.Fatalf("fatal: %v", err)
21: 	}
22: }
23: func run() error {
24: 	// Load config
25: 	cfgPath := "config.yaml"
26: 	if len(os.Args) > 1 {
27: 		cfgPath = os.Args[1]
28: 	}
29: 	cfg, err := config.Load(cfgPath)
30: 	if err != nil {
31: 		return fmt.Errorf("load config: %w", err)
32: 	}
33: 	// Create station manager
34: 	mgr, err := manager.NewFromConfig(cfg)
35: 	if err != nil {
36: 		return fmt.Errorf("create manager: %w", err)
37: 	}
38: 	// Start stations
39: 	if err := mgr.Start(); err != nil {
40: 		return fmt.Errorf("start stations: %w", err)
41: 	}
42: 	// Setup HTTP routes
43: 	mux := nethttp.NewServeMux()
44: 	mux.Handle("/stations", http.NewStationsHandler(mgr))
45: 	mux.HandleFunc("/healthz", http.HealthzHandler)
46: 	// Station-specific routes
47: 	streamHandler := http.NewStreamHandler(mgr)
48: 	metaHandler := http.NewMetaHandler(mgr)
49: 	mux.HandleFunc("/", func(w nethttp.ResponseWriter, r *nethttp.Request) {
50: 		if len(r.URL.Path) > 7 && r.URL.Path[len(r.URL.Path)-7:] == "/stream" {
51: 			streamHandler.ServeHTTP(w, r)
52: 			return
53: 		}
54: 		if len(r.URL.Path) > 5 && r.URL.Path[len(r.URL.Path)-5:] == "/meta" {
55: 			metaHandler.ServeHTTP(w, r)
56: 			return
57: 		}
58: 		nethttp.NotFound(w, r)
59: 	})
60: 	// Create HTTP server
61: 	addr := fmt.Sprintf("%s:%d", cfg.Listen.Host, cfg.Listen.Port)
62: 	srv := &nethttp.Server{
63: 		Addr:         addr,
64: 		Handler:      mux,
65: 		ReadTimeout:  15 * time.Second,
66: 		WriteTimeout: 0, // Streaming
67: 		IdleTimeout:  0, // Streaming
68: 		BaseContext: func(_ net.Listener) context.Context {
69: 			return context.Background()
70: 		},
71: 	}
72: 	// Graceful shutdown
73: 	shutdown := make(chan error, 1)
74: 	go func() {
75: 		sigint := make(chan os.Signal, 1)
76: 		signal.Notify(sigint, os.Interrupt, syscall.SIGTERM)
77: 		<-sigint
78: 		log.Println("shutting down...")
79: 		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
80: 		defer cancel()
81: 		shutdown <- srv.Shutdown(ctx)
82: 	}()
83: 	// Start server
84: 	log.Printf("listening on http://%s (try /stations)", addr)
85: 	if err := srv.ListenAndServe(); err != nil && err != nethttp.ErrServerClosed {
86: 		return fmt.Errorf("http server: %w", err)
87: 	}
88: 	// Wait for shutdown
89: 	if err := <-shutdown; err != nil {
90: 		return fmt.Errorf("shutdown: %w", err)
91: 	}
92: 	// Shutdown stations
93: 	if err := mgr.Shutdown(); err != nil {
94: 		return fmt.Errorf("shutdown stations: %w", err)
95: 	}
96: 	log.Println("shutdown complete")
97: 	return nil
98: }
</file>

<file path="internal/application/manager/manager.go">
  1: // ABOUTME: Station manager for lifecycle and lookup
  2: // ABOUTME: Creates stations from config and manages their goroutines
  3: package manager
  4: import (
  5: 	"context"
  6: 	"sync"
  7: 	"time"
  8: 	"github.com/harper/radio-metadata-proxy/internal/application/config"
  9: 	"github.com/harper/radio-metadata-proxy/internal/domain/station"
 10: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/metadata"
 11: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/ring"
 12: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/source"
 13: )
 14: type Manager struct {
 15: 	stations map[string]*station.Station
 16: 	mu       sync.RWMutex
 17: 	ctx      context.Context
 18: 	cancel   context.CancelFunc
 19: 	wg       sync.WaitGroup
 20: }
 21: func NewFromConfig(cfg *config.Config) (*Manager, error) {
 22: 	ctx, cancel := context.WithCancel(context.Background())
 23: 	mgr := &Manager{
 24: 		stations: make(map[string]*station.Station),
 25: 		ctx:      ctx,
 26: 		cancel:   cancel,
 27: 	}
 28: 	for _, stCfg := range cfg.Stations {
 29: 		// Create dependencies
 30: 		srcCfg := source.HTTPConfig{
 31: 			URL:            stCfg.Source.URL,
 32: 			ConnectTimeout: time.Duration(stCfg.Source.ConnectTimeoutMs) * time.Millisecond,
 33: 			ReadTimeout:    time.Duration(stCfg.Source.ReadTimeoutMs) * time.Millisecond,
 34: 			Headers:        stCfg.Source.RequestHeaders,
 35: 		}
 36: 		src := source.NewHTTP(srcCfg)
 37: 		metaCfg := metadata.HTTPConfig{
 38: 			URL:     stCfg.Metadata.URL,
 39: 			Timeout: time.Duration(stCfg.Metadata.PollMs) * time.Millisecond,
 40: 			Build: metadata.BuildConfig{
 41: 				Format:              stCfg.Metadata.Build.Format,
 42: 				StripSingleQuotes:   stCfg.Metadata.Build.StripSingleQuotes,
 43: 				NormalizeWhitespace: stCfg.Metadata.Build.NormalizeWhitespace,
 44: 				FallbackKeyOrder:    stCfg.Metadata.Build.FallbackKeyOrder,
 45: 			},
 46: 		}
 47: 		metaProv := metadata.NewHTTP(metaCfg)
 48: 		buffer := ring.New(stCfg.Buffering.RingBytes)
 49: 		// Create station
 50: 		stationCfg := station.Config{
 51: 			ID:             stCfg.ID,
 52: 			ICYName:        stCfg.ICY.Name,
 53: 			MetaInt:        stCfg.ICY.MetaInt,
 54: 			BitrateHint:    stCfg.ICY.BitrateHintKbps,
 55: 			PollInterval:   time.Duration(stCfg.Metadata.PollMs) * time.Millisecond,
 56: 			RingBufferSize: stCfg.Buffering.RingBytes,
 57: 			ChunkBusCap:    32,
 58: 		}
 59: 		st := station.New(stationCfg, src, metaProv, buffer)
 60: 		mgr.stations[stCfg.ID] = st
 61: 	}
 62: 	return mgr, nil
 63: }
 64: func (m *Manager) Get(id string) *station.Station {
 65: 	m.mu.RLock()
 66: 	defer m.mu.RUnlock()
 67: 	return m.stations[id]
 68: }
 69: func (m *Manager) List() []*station.Station {
 70: 	m.mu.RLock()
 71: 	defer m.mu.RUnlock()
 72: 	result := make([]*station.Station, 0, len(m.stations))
 73: 	for _, st := range m.stations {
 74: 		result = append(result, st)
 75: 	}
 76: 	return result
 77: }
 78: func (m *Manager) Start() error {
 79: 	m.mu.RLock()
 80: 	defer m.mu.RUnlock()
 81: 	for _, st := range m.stations {
 82: 		if err := st.Start(); err != nil {
 83: 			return err
 84: 		}
 85: 	}
 86: 	return nil
 87: }
 88: func (m *Manager) Shutdown() error {
 89: 	m.cancel()
 90: 	m.wg.Wait()
 91: 	// Shutdown all stations
 92: 	m.mu.RLock()
 93: 	defer m.mu.RUnlock()
 94: 	for _, st := range m.stations {
 95: 		if err := st.Shutdown(); err != nil {
 96: 			return err
 97: 		}
 98: 	}
 99: 	return nil
100: }
</file>

<file path="internal/infrastructure/metadata/http_test.go">
 1: // ABOUTME: Tests for HTTP metadata provider implementation
 2: // ABOUTME: Verifies JSON parsing and ICY formatting
 3: package metadata
 4: import (
 5: 	"context"
 6: 	"net/http"
 7: 	"net/http/httptest"
 8: 	"testing"
 9: 	"time"
10: )
11: func TestHTTPProvider_Fetch_JSON(t *testing.T) {
12: 	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
13: 		w.Header().Set("Content-Type", "application/json")
14: 		w.Write([]byte(`{"artist":"Test Artist","title":"Test Song"}`))
15: 	}))
16: 	defer server.Close()
17: 	cfg := HTTPConfig{
18: 		URL:     server.URL,
19: 		Timeout: 5 * time.Second,
20: 		Build: BuildConfig{
21: 			Format: "StreamTitle='{artist} - {title}';",
22: 		},
23: 	}
24: 	provider := NewHTTP(cfg)
25: 	ctx := context.Background()
26: 	result, err := provider.Fetch(ctx)
27: 	if err != nil {
28: 		t.Fatalf("Fetch failed: %v", err)
29: 	}
30: 	expected := "StreamTitle='Test Artist - Test Song';"
31: 	if result != expected {
32: 		t.Errorf("expected %q, got %q", expected, result)
33: 	}
34: }
35: func TestHTTPProvider_Fetch_NestedJSON(t *testing.T) {
36: 	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
37: 		w.Header().Set("Content-Type", "application/json")
38: 		w.Write([]byte(`{
39: 			"now": {
40: 				"firstLine": {"title": "Test Song"},
41: 				"secondLine": {"title": "Test Artist"}
42: 			}
43: 		}`))
44: 	}))
45: 	defer server.Close()
46: 	cfg := HTTPConfig{
47: 		URL:     server.URL,
48: 		Timeout: 5 * time.Second,
49: 		Build: BuildConfig{
50: 			Format: "StreamTitle='{artist} - {title}';",
51: 			FallbackKeyOrder: []string{
52: 				"now.secondLine.title",
53: 				"now.firstLine.title",
54: 			},
55: 		},
56: 	}
57: 	provider := NewHTTP(cfg)
58: 	ctx := context.Background()
59: 	result, err := provider.Fetch(ctx)
60: 	if err != nil {
61: 		t.Fatalf("Fetch failed: %v", err)
62: 	}
63: 	expected := "StreamTitle='Test Artist - Test Song';"
64: 	if result != expected {
65: 		t.Errorf("expected %q, got %q", expected, result)
66: 	}
67: }
</file>

<file path=".gitignore">
 1: # Binaries
 2: /icyproxy
 3: *.exe
 4: *.exe~
 5: *.dll
 6: *.so
 7: *.dylib
 8: 
 9: # Test artifacts
10: *.test
11: *.out
12: 
13: # Go workspace file
14: go.work
15: 
16: # IDE
17: .vscode/
18: .idea/
19: *.swp
20: *.swo
</file>

<file path="go.mod">
1: module github.com/harper/radio-metadata-proxy
2: 
3: go 1.23
4: 
5: require gopkg.in/yaml.v3 v3.0.1 // indirect
</file>

<file path="README.md">
 1: # Radio Metadata Proxy
 2: 
 3: Multi-station ICY metadata proxy for streaming radio with custom metadata injection.
 4: 
 5: ## Features
 6: 
 7: - Multiple stations from single daemon
 8: - ICY metadata injection (Shoutcast/Icecast compatible)
 9: - Ring buffer for stream smoothing
10: - Automatic reconnection with backoff
11: - Clean hexagonal architecture
12: 
13: ## Quick Start
14: 
15: ### Docker Compose (Recommended)
16: 
17: ```bash
18: # Edit config.yaml with your stations
19: docker compose up -d
20: 
21: # View logs
22: docker compose logs -f
23: 
24: # Stop
25: docker compose down
26: ```
27: 
28: ### Binary
29: 
30: ```bash
31: go build -o icyproxy ./cmd/icyproxy
32: ./icyproxy config.yaml
33: ```
34: 
35: ### Docker
36: 
37: ```bash
38: docker build -t icyproxy .
39: docker run -p 8000:8000 -v $(pwd)/config.yaml:/app/config.yaml:ro icyproxy
40: ```
41: 
42: ## Usage
43: 
44: ### Endpoints
45: 
46: - `GET /{station}/stream` - ICY stream
47: - `GET /{station}/meta` - JSON metadata
48: - `GET /stations` - List all stations
49: - `GET /healthz` - Health check
50: 
51: ### Example
52: 
53: ```bash
54: # List stations
55: curl http://localhost:8000/stations
56: 
57: # Stream audio (VLC, mpv, etc)
58: mpv http://localhost:8000/fip/stream
59: 
60: # Get metadata
61: curl http://localhost:8000/fip/meta
62: ```
63: 
64: ## Configuration
65: 
66: See `configs/example.yaml` for full configuration options.
67: 
68: ## Architecture
69: 
70: - **Domain Layer**: Station model, interfaces
71: - **Application Layer**: Manager, config
72: - **Infrastructure Layer**: HTTP implementations, ICY encoding, ring buffer
73: 
74: ## License
75: 
76: MIT
</file>

<file path="internal/infrastructure/http/handlers.go">
  1: // ABOUTME: HTTP handlers for station endpoints
  2: // ABOUTME: Implements stream, metadata, and health check routes
  3: package http
  4: import (
  5: 	"encoding/json"
  6: 	"fmt"
  7: 	"net/http"
  8: 	"strings"
  9: 	"github.com/harper/radio-metadata-proxy/internal/application/manager"
 10: 	"github.com/harper/radio-metadata-proxy/internal/domain/station"
 11: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/icy"
 12: )
 13: type StreamHandler struct {
 14: 	mgr *manager.Manager
 15: }
 16: func NewStreamHandler(mgr *manager.Manager) *StreamHandler {
 17: 	return &StreamHandler{mgr: mgr}
 18: }
 19: func (h *StreamHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 20: 	// Extract station ID from path: /{station}/stream
 21: 	parts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
 22: 	if len(parts) != 2 || parts[1] != "stream" {
 23: 		http.NotFound(w, r)
 24: 		return
 25: 	}
 26: 	stationID := parts[0]
 27: 	st := h.mgr.Get(stationID)
 28: 	if st == nil {
 29: 		http.NotFound(w, r)
 30: 		return
 31: 	}
 32: 	// Check if client wants ICY metadata
 33: 	wantsMetadata := r.Header.Get("Icy-MetaData") == "1"
 34: 	// Set ICY headers
 35: 	w.Header().Set("Content-Type", "audio/mpeg")
 36: 	w.Header().Set("icy-name", st.ICYName())
 37: 	w.Header().Set("icy-br", fmt.Sprintf("%d", st.BitrateHint()))
 38: 	w.Header().Set("Cache-Control", "no-store")
 39: 	w.Header().Set("Connection", "close")
 40: 	// Only send metaint if client wants metadata
 41: 	if wantsMetadata {
 42: 		w.Header().Set("icy-metaint", fmt.Sprintf("%d", st.MetaInt()))
 43: 	}
 44: 	w.WriteHeader(http.StatusOK)
 45: 	// Subscribe to station chunks
 46: 	client := &station.Client{ID: fmt.Sprintf("http-%p", r)}
 47: 	chunks := st.Subscribe(client)
 48: 	defer st.Unsubscribe(client)
 49: 	// Stream with ICY metadata injection
 50: 	flusher, ok := w.(http.Flusher)
 51: 	if !ok {
 52: 		return
 53: 	}
 54: 	var metaInt int
 55: 	var bytesUntilMeta int
 56: 	var lastMeta string
 57: 	if wantsMetadata {
 58: 		metaInt = st.MetaInt()
 59: 		bytesUntilMeta = metaInt
 60: 	}
 61: 	for {
 62: 		select {
 63: 		case <-r.Context().Done():
 64: 			return
 65: 		case chunk, ok := <-chunks:
 66: 			if !ok {
 67: 				return
 68: 			}
 69: 			// Write chunk in pieces, injecting metadata at intervals
 70: 			for len(chunk) > 0 {
 71: 				if wantsMetadata {
 72: 					// Write up to next metadata point
 73: 					toWrite := len(chunk)
 74: 					if toWrite > bytesUntilMeta {
 75: 						toWrite = bytesUntilMeta
 76: 					}
 77: 					n, err := w.Write(chunk[:toWrite])
 78: 					if err != nil {
 79: 						return
 80: 					}
 81: 					chunk = chunk[n:]
 82: 					bytesUntilMeta -= n
 83: 					// Inject metadata if needed
 84: 					if bytesUntilMeta == 0 {
 85: 						meta := st.CurrentMetadata()
 86: 						if meta == "" {
 87: 							meta = "StreamTitle='';"
 88: 						}
 89: 						// Only send metadata if it changed
 90: 						if meta != lastMeta {
 91: 							lastMeta = meta
 92: 						}
 93: 						metaBlock := icy.BuildBlock(meta)
 94: 						if _, err := w.Write(metaBlock); err != nil {
 95: 							return
 96: 						}
 97: 						bytesUntilMeta = metaInt
 98: 					}
 99: 				} else {
100: 					// No metadata - just stream audio directly
101: 					n, err := w.Write(chunk)
102: 					if err != nil {
103: 						return
104: 					}
105: 					chunk = chunk[n:]
106: 				}
107: 			}
108: 			flusher.Flush()
109: 		}
110: 	}
111: }
112: type MetaHandler struct {
113: 	mgr *manager.Manager
114: }
115: func NewMetaHandler(mgr *manager.Manager) *MetaHandler {
116: 	return &MetaHandler{mgr: mgr}
117: }
118: func (h *MetaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
119: 	parts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
120: 	if len(parts) != 2 || parts[1] != "meta" {
121: 		http.NotFound(w, r)
122: 		return
123: 	}
124: 	stationID := parts[0]
125: 	st := h.mgr.Get(stationID)
126: 	if st == nil {
127: 		http.NotFound(w, r)
128: 		return
129: 	}
130: 	type response struct {
131: 		Current      string  `json:"current"`
132: 		UpdatedAt    *string `json:"updated_at,omitempty"`
133: 		SourceHealthy bool   `json:"sourceHealthy"`
134: 	}
135: 	var updatedAt *string
136: 	if t := st.LastMetadataUpdate(); t != nil {
137: 		s := t.Format("2006-01-02T15:04:05Z07:00")
138: 		updatedAt = &s
139: 	}
140: 	resp := response{
141: 		Current:      st.CurrentMetadata(),
142: 		UpdatedAt:    updatedAt,
143: 		SourceHealthy: st.SourceHealthy(),
144: 	}
145: 	w.Header().Set("Content-Type", "application/json")
146: 	json.NewEncoder(w).Encode(resp)
147: }
148: type StationsHandler struct {
149: 	mgr *manager.Manager
150: }
151: func NewStationsHandler(mgr *manager.Manager) *StationsHandler {
152: 	return &StationsHandler{mgr: mgr}
153: }
154: func (h *StationsHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
155: 	type stationInfo struct {
156: 		ID            string `json:"id"`
157: 		StreamURL     string `json:"stream_url"`
158: 		MetaURL       string `json:"meta_url"`
159: 		Clients       int    `json:"clients"`
160: 		SourceHealthy bool   `json:"sourceHealthy"`
161: 	}
162: 	stations := h.mgr.List()
163: 	result := make([]stationInfo, 0, len(stations))
164: 	for _, st := range stations {
165: 		result = append(result, stationInfo{
166: 			ID:            st.ID(),
167: 			StreamURL:     fmt.Sprintf("/%s/stream", st.ID()),
168: 			MetaURL:       fmt.Sprintf("/%s/meta", st.ID()),
169: 			Clients:       st.ClientCount(),
170: 			SourceHealthy: st.SourceHealthy(),
171: 		})
172: 	}
173: 	w.Header().Set("Content-Type", "application/json")
174: 	json.NewEncoder(w).Encode(result)
175: }
176: func HealthzHandler(w http.ResponseWriter, r *http.Request) {
177: 	type response struct {
178: 		OK bool `json:"ok"`
179: 	}
180: 	w.Header().Set("Content-Type", "application/json")
181: 	json.NewEncoder(w).Encode(response{OK: true})
182: }
</file>

<file path="internal/infrastructure/metadata/http.go">
  1: // ABOUTME: HTTP metadata provider implementation with JSON parsing
  2: // ABOUTME: Formats metadata into ICY-compatible strings
  3: package metadata
  4: import (
  5: 	"context"
  6: 	"encoding/json"
  7: 	"fmt"
  8: 	"io"
  9: 	"net/http"
 10: 	"strings"
 11: 	"time"
 12: )
 13: type BuildConfig struct {
 14: 	Format              string
 15: 	StripSingleQuotes   bool
 16: 	NormalizeWhitespace bool
 17: 	FallbackKeyOrder    []string
 18: }
 19: type HTTPConfig struct {
 20: 	URL     string
 21: 	Timeout time.Duration
 22: 	Build   BuildConfig
 23: }
 24: type HTTPProvider struct {
 25: 	cfg    HTTPConfig
 26: 	client *http.Client
 27: }
 28: func NewHTTP(cfg HTTPConfig) *HTTPProvider {
 29: 	client := &http.Client{
 30: 		Timeout: cfg.Timeout,
 31: 	}
 32: 	return &HTTPProvider{
 33: 		cfg:    cfg,
 34: 		client: client,
 35: 	}
 36: }
 37: func (h *HTTPProvider) Fetch(ctx context.Context) (string, error) {
 38: 	req, err := http.NewRequestWithContext(ctx, "GET", h.cfg.URL, nil)
 39: 	if err != nil {
 40: 		return "", fmt.Errorf("create request: %w", err)
 41: 	}
 42: 	req.Header.Set("Cache-Control", "no-store")
 43: 	resp, err := h.client.Do(req)
 44: 	if err != nil {
 45: 		return "", fmt.Errorf("http request: %w", err)
 46: 	}
 47: 	defer resp.Body.Close()
 48: 	body, err := io.ReadAll(io.LimitReader(resp.Body, 64*1024))
 49: 	if err != nil {
 50: 		return "", fmt.Errorf("read body: %w", err)
 51: 	}
 52: 	// Parse JSON
 53: 	var data map[string]interface{}
 54: 	if err := json.Unmarshal(body, &data); err != nil {
 55: 		return "", fmt.Errorf("parse json: %w", err)
 56: 	}
 57: 	// Build ICY string from format template with all placeholders
 58: 	result := h.cfg.Build.Format
 59: 	// Replace all placeholders: {artist}, {title}, {album}, {year}, etc.
 60: 	placeholders := []string{"artist", "title", "album", "year", "label"}
 61: 	for _, placeholder := range placeholders {
 62: 		value := h.extractValue(data, placeholder)
 63: 		result = strings.ReplaceAll(result, "{"+placeholder+"}", value)
 64: 	}
 65: 	// Apply transformations
 66: 	if h.cfg.Build.StripSingleQuotes {
 67: 		result = strings.ReplaceAll(result, "'", "")
 68: 	}
 69: 	if h.cfg.Build.NormalizeWhitespace {
 70: 		result = strings.Join(strings.Fields(result), " ")
 71: 	}
 72: 	return result, nil
 73: }
 74: // extractValue tries to extract a value using fallback paths or simple key lookup
 75: func (h *HTTPProvider) extractValue(data map[string]interface{}, placeholder string) string {
 76: 	// If FallbackKeyOrder is configured, use it
 77: 	if len(h.cfg.Build.FallbackKeyOrder) > 0 {
 78: 		// Map placeholder to fallback path index
 79: 		// Order: artist, title, album, year, label, ...
 80: 		placeholderMap := map[string]int{
 81: 			"artist": 0,
 82: 			"title":  1,
 83: 			"album":  2,
 84: 			"year":   3,
 85: 			"label":  4,
 86: 		}
 87: 		if idx, ok := placeholderMap[placeholder]; ok && idx < len(h.cfg.Build.FallbackKeyOrder) {
 88: 			path := h.cfg.Build.FallbackKeyOrder[idx]
 89: 			if val := getNestedString(data, path); val != "" {
 90: 				return val
 91: 			}
 92: 		}
 93: 	}
 94: 	// Fallback to simple key lookup
 95: 	return getString(data, placeholder)
 96: }
 97: func getString(data map[string]interface{}, key string) string {
 98: 	if val, ok := data[key].(string); ok {
 99: 		return val
100: 	}
101: 	return ""
102: }
103: // getNestedString traverses a nested JSON path using dot notation
104: // e.g., "now.secondLine.title" → data["now"]["secondLine"]["title"]
105: // Handles strings and numbers (converts numbers to strings)
106: func getNestedString(data map[string]interface{}, path string) string {
107: 	parts := strings.Split(path, ".")
108: 	var current interface{} = data
109: 	for _, part := range parts {
110: 		switch v := current.(type) {
111: 		case map[string]interface{}:
112: 			current = v[part]
113: 		default:
114: 			return ""
115: 		}
116: 	}
117: 	// Handle different types
118: 	switch v := current.(type) {
119: 	case string:
120: 		return v
121: 	case float64:
122: 		return fmt.Sprintf("%.0f", v)
123: 	case int:
124: 		return fmt.Sprintf("%d", v)
125: 	case bool:
126: 		return fmt.Sprintf("%t", v)
127: 	}
128: 	return ""
129: }
</file>

<file path="internal/domain/station/station_test.go">
  1: // ABOUTME: Tests for station domain model
  2: // ABOUTME: Verifies lifecycle, client management, and metadata updates
  3: package station
  4: import (
  5: 	"bytes"
  6: 	"context"
  7: 	"io"
  8: 	"testing"
  9: 	"time"
 10: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/ring"
 11: )
 12: func TestNew(t *testing.T) {
 13: 	cfg := Config{
 14: 		ID:      "test",
 15: 		MetaInt: 16384,
 16: 	}
 17: 	s := New(cfg, nil, nil, nil)
 18: 	if s.ID() != "test" {
 19: 		t.Errorf("expected ID 'test', got %q", s.ID())
 20: 	}
 21: }
 22: func TestStation_CurrentMetadata(t *testing.T) {
 23: 	cfg := Config{
 24: 		ID:      "test",
 25: 		MetaInt: 16384,
 26: 	}
 27: 	s := New(cfg, nil, nil, nil)
 28: 	// Initially empty
 29: 	if meta := s.CurrentMetadata(); meta != "" {
 30: 		t.Errorf("expected empty metadata, got %q", meta)
 31: 	}
 32: 	// Set metadata
 33: 	s.UpdateMetadata("StreamTitle='Test';")
 34: 	if meta := s.CurrentMetadata(); meta != "StreamTitle='Test';" {
 35: 		t.Errorf("expected 'StreamTitle='Test';', got %q", meta)
 36: 	}
 37: }
 38: func TestStation_ClientManagement(t *testing.T) {
 39: 	cfg := Config{
 40: 		ID:      "test",
 41: 		MetaInt: 16384,
 42: 	}
 43: 	s := New(cfg, nil, nil, nil)
 44: 	if count := s.ClientCount(); count != 0 {
 45: 		t.Errorf("expected 0 clients, got %d", count)
 46: 	}
 47: 	client := &Client{ID: "c1"}
 48: 	s.AddClient(client)
 49: 	if count := s.ClientCount(); count != 1 {
 50: 		t.Errorf("expected 1 client, got %d", count)
 51: 	}
 52: 	s.RemoveClient(client)
 53: 	if count := s.ClientCount(); count != 0 {
 54: 		t.Errorf("expected 0 clients after removal, got %d", count)
 55: 	}
 56: }
 57: func TestStation_Properties(t *testing.T) {
 58: 	cfg := Config{
 59: 		ID:          "fip",
 60: 		ICYName:     "FIP Radio",
 61: 		MetaInt:     16384,
 62: 		BitrateHint: 128,
 63: 	}
 64: 	s := New(cfg, nil, nil, nil)
 65: 	if s.ICYName() != "FIP Radio" {
 66: 		t.Errorf("expected ICYName 'FIP Radio', got %q", s.ICYName())
 67: 	}
 68: 	if s.MetaInt() != 16384 {
 69: 		t.Errorf("expected MetaInt 16384, got %d", s.MetaInt())
 70: 	}
 71: 	if s.BitrateHint() != 128 {
 72: 		t.Errorf("expected BitrateHint 128, got %d", s.BitrateHint())
 73: 	}
 74: 	if s.SourceHealthy() {
 75: 		t.Error("expected SourceHealthy false initially")
 76: 	}
 77: 	s.SetSourceHealthy(true)
 78: 	if !s.SourceHealthy() {
 79: 		t.Error("expected SourceHealthy true after set")
 80: 	}
 81: }
 82: // Mock implementations for testing
 83: type mockSource struct {
 84: 	data []byte
 85: }
 86: func (m *mockSource) Connect(ctx context.Context) (io.ReadCloser, error) {
 87: 	return io.NopCloser(bytes.NewReader(m.data)), nil
 88: }
 89: type mockMetadataProvider struct {
 90: 	meta string
 91: }
 92: func (m *mockMetadataProvider) Fetch(ctx context.Context) (string, error) {
 93: 	return m.meta, nil
 94: }
 95: func TestStation_Start(t *testing.T) {
 96: 	// Create test data
 97: 	testData := bytes.Repeat([]byte("test audio data "), 100)
 98: 	src := &mockSource{data: testData}
 99: 	meta := &mockMetadataProvider{meta: "StreamTitle='Test Song';"}
100: 	buffer := ring.New(1024)
101: 	cfg := Config{
102: 		ID:             "test",
103: 		MetaInt:        16384,
104: 		PollInterval:   100 * time.Millisecond,
105: 		RingBufferSize: 1024,
106: 		ChunkBusCap:    32,
107: 	}
108: 	s := New(cfg, src, meta, buffer)
109: 	// Start station goroutines
110: 	err := s.Start()
111: 	if err != nil {
112: 		t.Fatalf("Start failed: %v", err)
113: 	}
114: 	// Wait for data to be read and buffered
115: 	time.Sleep(200 * time.Millisecond)
116: 	// Check that ring buffer has data
117: 	snapshot := buffer.Snapshot()
118: 	if len(snapshot) == 0 {
119: 		t.Error("expected ring buffer to contain data after Start")
120: 	}
121: 	// Check that metadata was polled
122: 	if s.CurrentMetadata() != "StreamTitle='Test Song';" {
123: 		t.Errorf("expected metadata to be polled, got %q", s.CurrentMetadata())
124: 	}
125: 	// Check that source is marked healthy
126: 	if !s.SourceHealthy() {
127: 		t.Error("expected source to be marked healthy after successful connection")
128: 	}
129: 	// Shutdown
130: 	err = s.Shutdown()
131: 	if err != nil {
132: 		t.Fatalf("Shutdown failed: %v", err)
133: 	}
134: }
135: func TestStation_Subscribe(t *testing.T) {
136: 	testData := bytes.Repeat([]byte("test"), 50)
137: 	src := &mockSource{data: testData}
138: 	meta := &mockMetadataProvider{meta: "StreamTitle='Test';"}
139: 	buffer := ring.New(1024)
140: 	cfg := Config{
141: 		ID:             "test",
142: 		MetaInt:        16384,
143: 		PollInterval:   100 * time.Millisecond,
144: 		RingBufferSize: 1024,
145: 		ChunkBusCap:    32,
146: 	}
147: 	s := New(cfg, src, meta, buffer)
148: 	s.Start()
149: 	defer s.Shutdown()
150: 	// Subscribe to chunks
151: 	client := &Client{ID: "test-client"}
152: 	chunks := s.Subscribe(client)
153: 	// Should receive chunks
154: 	select {
155: 	case chunk := <-chunks:
156: 		if len(chunk) == 0 {
157: 			t.Error("expected non-empty chunk")
158: 		}
159: 	case <-time.After(500 * time.Millisecond):
160: 		t.Error("timeout waiting for chunk")
161: 	}
162: 	// Unsubscribe
163: 	s.Unsubscribe(client)
164: 	// Should not receive more chunks after unsubscribe
165: 	// (drain any buffered chunks first)
166: 	for len(chunks) > 0 {
167: 		<-chunks
168: 	}
169: }
</file>

<file path="config.yaml">
 1: listen:
 2:   host: 0.0.0.0
 3:   port: 8000
 4: stations:
 5:   - id: "fip"
 6:     icy:
 7:       name: "FIP (proxy)"
 8:       metaint: 16384
 9:       bitrate_hint_kbps: 128
10:     source:
11:       url: "https://icecast.radiofrance.fr/fip-midfi.mp3?id=radiofrance"
12:       request_headers:
13:         Icy-MetaData: "0"
14:       connect_timeout_ms: 5000
15:       read_timeout_ms: 15000
16:     metadata:
17:       url: "https://fip-metadata.fly.dev/api/metadata/fip"
18:       poll_ms: 3000
19:       build:
20:         format: "StreamTitle='{artist} - {title}';Title='{title}';Artist='{artist}';StreamUrl='http://localhost:8000/fip/stream';"
21:         strip_single_quotes: true
22:         normalize_whitespace: true
23:         fallback_key_order:
24:           - now.secondLine.title      # artist
25:           - now.firstLine.title        # title
26:     buffering:
27:       ring_bytes: 262144
28: logging:
29:   level: info
30:   json: false
</file>

<file path="internal/domain/station/station.go">
  1: // ABOUTME: Station domain model coordinating streaming, metadata, and clients
  2: // ABOUTME: Manages lifecycle of goroutines for source reading and metadata polling
  3: package station
  4: import (
  5: 	"context"
  6: 	"io"
  7: 	"sync"
  8: 	"sync/atomic"
  9: 	"time"
 10: 	"github.com/harper/radio-metadata-proxy/internal/domain"
 11: 	"github.com/harper/radio-metadata-proxy/internal/infrastructure/ring"
 12: )
 13: type Config struct {
 14: 	ID             string
 15: 	ICYName        string
 16: 	MetaInt        int
 17: 	BitrateHint    int
 18: 	PollInterval   time.Duration
 19: 	RingBufferSize int
 20: 	ChunkBusCap    int
 21: }
 22: type Station struct {
 23: 	id          string
 24: 	icyName     string
 25: 	metaInt     int
 26: 	bitrateHint int
 27: 	source   domain.StreamSource
 28: 	metadata domain.MetadataProvider
 29: 	buffer   *ring.Buffer
 30: 	pollInterval time.Duration
 31: 	currentMeta   atomic.Pointer[string]
 32: 	lastMetaAt    atomic.Pointer[time.Time]
 33: 	sourceHealthy atomic.Bool
 34: 	clients   map[*Client]struct{}
 35: 	clientsMu sync.Mutex
 36: 	chunkBus chan []byte
 37: 	ctx    context.Context
 38: 	cancel context.CancelFunc
 39: }
 40: type Client struct {
 41: 	ID string
 42: 	ch chan []byte
 43: }
 44: func New(cfg Config, source domain.StreamSource, metadata domain.MetadataProvider, buffer *ring.Buffer) *Station {
 45: 	ctx, cancel := context.WithCancel(context.Background())
 46: 	return &Station{
 47: 		id:           cfg.ID,
 48: 		icyName:      cfg.ICYName,
 49: 		metaInt:      cfg.MetaInt,
 50: 		bitrateHint:  cfg.BitrateHint,
 51: 		source:       source,
 52: 		metadata:     metadata,
 53: 		buffer:       buffer,
 54: 		pollInterval: cfg.PollInterval,
 55: 		clients:      make(map[*Client]struct{}),
 56: 		chunkBus:     make(chan []byte, cfg.ChunkBusCap),
 57: 		ctx:          ctx,
 58: 		cancel:       cancel,
 59: 	}
 60: }
 61: func (s *Station) ID() string {
 62: 	return s.id
 63: }
 64: func (s *Station) CurrentMetadata() string {
 65: 	p := s.currentMeta.Load()
 66: 	if p == nil {
 67: 		return ""
 68: 	}
 69: 	return *p
 70: }
 71: func (s *Station) UpdateMetadata(meta string) {
 72: 	s.currentMeta.Store(&meta)
 73: 	now := time.Now()
 74: 	s.lastMetaAt.Store(&now)
 75: }
 76: func (s *Station) LastMetadataUpdate() *time.Time {
 77: 	return s.lastMetaAt.Load()
 78: }
 79: func (s *Station) AddClient(c *Client) {
 80: 	s.clientsMu.Lock()
 81: 	s.clients[c] = struct{}{}
 82: 	s.clientsMu.Unlock()
 83: }
 84: func (s *Station) RemoveClient(c *Client) {
 85: 	s.clientsMu.Lock()
 86: 	delete(s.clients, c)
 87: 	s.clientsMu.Unlock()
 88: }
 89: func (s *Station) ClientCount() int {
 90: 	s.clientsMu.Lock()
 91: 	defer s.clientsMu.Unlock()
 92: 	return len(s.clients)
 93: }
 94: func (s *Station) ICYName() string {
 95: 	return s.icyName
 96: }
 97: func (s *Station) MetaInt() int {
 98: 	return s.metaInt
 99: }
100: func (s *Station) BitrateHint() int {
101: 	return s.bitrateHint
102: }
103: func (s *Station) SourceHealthy() bool {
104: 	return s.sourceHealthy.Load()
105: }
106: func (s *Station) SetSourceHealthy(healthy bool) {
107: 	s.sourceHealthy.Store(healthy)
108: }
109: func (s *Station) Subscribe(c *Client) <-chan []byte {
110: 	c.ch = make(chan []byte, 64)
111: 	s.AddClient(c)
112: 	return c.ch
113: }
114: func (s *Station) Unsubscribe(c *Client) {
115: 	s.RemoveClient(c)
116: 	if c.ch != nil {
117: 		close(c.ch)
118: 		c.ch = nil
119: 	}
120: }
121: func (s *Station) Start() error {
122: 	// Start source reader goroutine
123: 	go s.runSourceReader()
124: 	// Start metadata poller goroutine
125: 	go s.runMetadataPoller()
126: 	// Start fan-out goroutine
127: 	go s.runFanOut()
128: 	return nil
129: }
130: func (s *Station) Shutdown() error {
131: 	s.cancel()
132: 	return nil
133: }
134: func (s *Station) runSourceReader() {
135: 	stream, err := s.source.Connect(s.ctx)
136: 	if err != nil {
137: 		s.SetSourceHealthy(false)
138: 		return
139: 	}
140: 	defer stream.Close()
141: 	s.SetSourceHealthy(true)
142: 	buf := make([]byte, 8192)
143: 	for {
144: 		select {
145: 		case <-s.ctx.Done():
146: 			return
147: 		default:
148: 		}
149: 		n, err := stream.Read(buf)
150: 		if n > 0 {
151: 			chunk := make([]byte, n)
152: 			copy(chunk, buf[:n])
153: 			// Write to ring buffer
154: 			s.buffer.Write(chunk)
155: 			// Send to fan-out
156: 			select {
157: 			case s.chunkBus <- chunk:
158: 			case <-s.ctx.Done():
159: 				return
160: 			}
161: 		}
162: 		if err != nil {
163: 			if err != io.EOF {
164: 				s.SetSourceHealthy(false)
165: 			}
166: 			return
167: 		}
168: 	}
169: }
170: func (s *Station) runMetadataPoller() {
171: 	ticker := time.NewTicker(s.pollInterval)
172: 	defer ticker.Stop()
173: 	// Poll immediately on start
174: 	if meta, err := s.metadata.Fetch(s.ctx); err == nil {
175: 		s.UpdateMetadata(meta)
176: 	}
177: 	for {
178: 		select {
179: 		case <-s.ctx.Done():
180: 			return
181: 		case <-ticker.C:
182: 			if meta, err := s.metadata.Fetch(s.ctx); err == nil {
183: 				s.UpdateMetadata(meta)
184: 			}
185: 		}
186: 	}
187: }
188: func (s *Station) runFanOut() {
189: 	for {
190: 		select {
191: 		case <-s.ctx.Done():
192: 			return
193: 		case chunk := <-s.chunkBus:
194: 			// Distribute chunk to all subscribed clients
195: 			s.clientsMu.Lock()
196: 			for client := range s.clients {
197: 				if client.ch != nil {
198: 					select {
199: 					case client.ch <- chunk:
200: 					default:
201: 						// Client buffer full, skip this chunk
202: 					}
203: 				}
204: 			}
205: 			s.clientsMu.Unlock()
206: 		}
207: 	}
208: }
</file>

</files>
